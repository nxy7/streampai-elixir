// Generated by AshTypescript
// Do not edit this file manually

import { Channel } from "phoenix";
import * as RpcHooks from "../lib/rpcHooks";


// RPC Action Hook Context Type
export type ActionHookContext = Record<string, any>;

// RPC Validation Hook Context Type
export type ValidationHookContext = Record<string, any>;

export type UUID = string;
export type UtcDateTime = string;
export type UtcDateTimeUsec = string;

// Livestream Schema
export type LivestreamResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "category" | "subcategory" | "language" | "tags" | "thumbnailUrl" | "thumbnailFileId" | "startedAt" | "endedAt" | "userId" | "averageViewers" | "peakViewers" | "messagesAmount" | "durationSeconds" | "platforms";
  id: UUID;
  title: string;
  description: string | null;
  category: "gaming" | "music" | "tech" | "art" | "talk" | "irl" | "just_chatting" | null;
  subcategory: string | null;
  language: string | null;
  tags: Array<string> | null;
  thumbnailUrl: string | null;
  thumbnailFileId: UUID | null;
  startedAt: UtcDateTime;
  endedAt: UtcDateTime | null;
  userId: UUID;
  averageViewers: number | null;
  peakViewers: number | null;
  messagesAmount: number | null;
  durationSeconds: number | null;
  platforms: Array<string> | null;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
  thumbnailFile: { __type: "Relationship"; __resource: FileResourceSchema | null; };
  streamEvents: { __type: "Relationship"; __array: true; __resource: StreamEventResourceSchema; };
};



export type LivestreamAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "category" | "subcategory" | "language" | "tags" | "thumbnailUrl" | "thumbnailFileId" | "startedAt" | "endedAt" | "userId";
  id: UUID;
  title: string;
  description: string | null;
  category: "gaming" | "music" | "tech" | "art" | "talk" | "irl" | "just_chatting" | null;
  subcategory: string | null;
  language: string | null;
  tags: Array<string> | null;
  thumbnailUrl: string | null;
  thumbnailFileId: UUID | null;
  startedAt: UtcDateTime;
  endedAt: UtcDateTime | null;
  userId: UUID;
};


// StreamEvent Schema
export type StreamEventResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "type" | "authorId" | "livestreamId" | "userId" | "platform" | "viewerId" | "wasDisplayed" | "insertedAt";
  id: UUID;
  type: "chat_message" | "donation" | "follow" | "raid" | "subscription" | "stream_updated" | "platform_started" | "platform_stopped";
  authorId: string;
  livestreamId: UUID;
  userId: UUID;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble" | null;
  viewerId: string | null;
  wasDisplayed: boolean | null;
  insertedAt: UtcDateTimeUsec;
  data: { __type: "Union"; __primitiveFields: never; chatMessage?: StreampaiStreamEventDataChatMessageDataResourceSchema; donation?: StreampaiStreamEventDataDonationDataResourceSchema; follow?: StreampaiStreamEventDataFollowDataResourceSchema; subscription?: StreampaiStreamEventDataSubscriptionDataResourceSchema; raid?: StreampaiStreamEventDataRaidDataResourceSchema; streamUpdated?: StreampaiStreamEventDataStreamUpdatedDataResourceSchema; platformStarted?: StreampaiStreamEventDataPlatformEventDataResourceSchema; platformStopped?: StreampaiStreamEventDataPlatformEventDataResourceSchema; };
};



export type StreamEventAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "type" | "authorId" | "livestreamId" | "userId" | "platform" | "viewerId" | "wasDisplayed" | "insertedAt";
  id: UUID;
  type: "chat_message" | "donation" | "follow" | "raid" | "subscription" | "stream_updated" | "platform_started" | "platform_stopped";
  authorId: string;
  livestreamId: UUID;
  userId: UUID;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble" | null;
  viewerId: string | null;
  wasDisplayed: boolean | null;
  insertedAt: UtcDateTimeUsec;
  data: { __type: "Union"; __primitiveFields: never; chatMessage?: StreampaiStreamEventDataChatMessageDataAttributesOnlySchema; donation?: StreampaiStreamEventDataDonationDataAttributesOnlySchema; follow?: StreampaiStreamEventDataFollowDataAttributesOnlySchema; subscription?: StreampaiStreamEventDataSubscriptionDataAttributesOnlySchema; raid?: StreampaiStreamEventDataRaidDataAttributesOnlySchema; streamUpdated?: StreampaiStreamEventDataStreamUpdatedDataAttributesOnlySchema; platformStarted?: StreampaiStreamEventDataPlatformEventDataAttributesOnlySchema; platformStopped?: StreampaiStreamEventDataPlatformEventDataAttributesOnlySchema; };
};


// StreamViewer Schema
export type StreamViewerResourceSchema = {
  __type: "Resource";
  __primitiveFields: "viewerId" | "userId" | "platform" | "displayName" | "avatarUrl" | "channelUrl" | "isVerified" | "isOwner" | "isModerator" | "isPatreon" | "notes" | "aiSummary" | "firstSeenAt" | "lastSeenAt";
  viewerId: string;
  userId: UUID;
  platform: "twitch" | "youtube" | "facebook" | "kick";
  displayName: string;
  avatarUrl: string | null;
  channelUrl: string | null;
  isVerified: boolean | null;
  isOwner: boolean | null;
  isModerator: boolean | null;
  isPatreon: boolean | null;
  notes: string | null;
  aiSummary: string | null;
  firstSeenAt: UtcDateTimeUsec;
  lastSeenAt: UtcDateTimeUsec;
};



export type StreamViewerAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "viewerId" | "userId" | "platform" | "displayName" | "avatarUrl" | "channelUrl" | "isVerified" | "isOwner" | "isModerator" | "isPatreon" | "notes" | "aiSummary" | "firstSeenAt" | "lastSeenAt";
  viewerId: string;
  userId: UUID;
  platform: "twitch" | "youtube" | "facebook" | "kick";
  displayName: string;
  avatarUrl: string | null;
  channelUrl: string | null;
  isVerified: boolean | null;
  isOwner: boolean | null;
  isModerator: boolean | null;
  isPatreon: boolean | null;
  notes: string | null;
  aiSummary: string | null;
  firstSeenAt: UtcDateTimeUsec;
  lastSeenAt: UtcDateTimeUsec;
};


// BannedViewer Schema
export type BannedViewerResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "platform" | "viewerUsername" | "viewerPlatformId" | "reason" | "durationSeconds" | "expiresAt" | "isActive" | "platformBanId" | "unbannedAt" | "insertedAt" | "updatedAt";
  id: UUID;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
  viewerUsername: string;
  viewerPlatformId: string;
  reason: string | null;
  durationSeconds: number | null;
  expiresAt: UtcDateTimeUsec | null;
  isActive: boolean;
  platformBanId: string | null;
  unbannedAt: UtcDateTimeUsec | null;
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
};



export type BannedViewerAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "platform" | "viewerUsername" | "viewerPlatformId" | "reason" | "durationSeconds" | "expiresAt" | "isActive" | "platformBanId" | "unbannedAt" | "insertedAt" | "updatedAt";
  id: UUID;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
  viewerUsername: string;
  viewerPlatformId: string;
  reason: string | null;
  durationSeconds: number | null;
  expiresAt: UtcDateTimeUsec | null;
  isActive: boolean;
  platformBanId: string | null;
  unbannedAt: UtcDateTimeUsec | null;
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
};


// CurrentStreamData Schema
export type CurrentStreamDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "status" | "streamData" | "cloudflareData" | "youtubeData" | "twitchData" | "kickData" | "activeAlert" | "highlightedMessage" | "alertboxState";
  id: UUID;
  status: string;
  streamData: Record<string, any>;
  cloudflareData: Record<string, any>;
  youtubeData: Record<string, any>;
  twitchData: Record<string, any>;
  kickData: Record<string, any>;
  activeAlert: Record<string, any> | null;
  highlightedMessage: Record<string, any> | null;
  alertboxState: Record<string, any>;
};



export type CurrentStreamDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "status" | "streamData" | "cloudflareData" | "youtubeData" | "twitchData" | "kickData" | "activeAlert" | "highlightedMessage" | "alertboxState";
  id: UUID;
  status: string;
  streamData: Record<string, any>;
  cloudflareData: Record<string, any>;
  youtubeData: Record<string, any>;
  twitchData: Record<string, any>;
  kickData: Record<string, any>;
  activeAlert: Record<string, any> | null;
  highlightedMessage: Record<string, any> | null;
  alertboxState: Record<string, any>;
};


// StreamTimer Schema
export type StreamTimerResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "label" | "content" | "intervalSeconds" | "disabledAt" | "insertedAt" | "updatedAt";
  id: UUID;
  label: string;
  content: string;
  intervalSeconds: number;
  disabledAt: UtcDateTimeUsec | null;
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
};



export type StreamTimerAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "label" | "content" | "intervalSeconds" | "disabledAt" | "insertedAt" | "updatedAt";
  id: UUID;
  label: string;
  content: string;
  intervalSeconds: number;
  disabledAt: UtcDateTimeUsec | null;
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
};


// HighlightedMessage Schema
export type HighlightedMessageResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "chatMessageId" | "message" | "senderUsername" | "senderChannelId" | "platform" | "viewerId" | "highlightedAt" | "userId";
  id: UUID;
  chatMessageId: string;
  message: string;
  senderUsername: string;
  senderChannelId: string;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
  viewerId: string | null;
  highlightedAt: UtcDateTimeUsec;
  userId: UUID;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



export type HighlightedMessageAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "chatMessageId" | "message" | "senderUsername" | "senderChannelId" | "platform" | "viewerId" | "highlightedAt" | "userId";
  id: UUID;
  chatMessageId: string;
  message: string;
  senderUsername: string;
  senderChannelId: string;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
  viewerId: string | null;
  highlightedAt: UtcDateTimeUsec;
  userId: UUID;
};


// ChatBotConfig Schema
export type ChatBotConfigResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "enabled" | "greetingEnabled" | "greetingMessage" | "commandPrefix" | "aiChatEnabled" | "aiPersonality" | "aiBotName" | "aiProvider" | "autoShoutoutEnabled" | "linkProtectionEnabled" | "slowModeOnRaidEnabled" | "insertedAt" | "updatedAt";
  id: UUID;
  enabled: boolean;
  greetingEnabled: boolean;
  greetingMessage: string;
  commandPrefix: string;
  aiChatEnabled: boolean;
  aiPersonality: string | null;
  aiBotName: string;
  aiProvider: string;
  autoShoutoutEnabled: boolean;
  linkProtectionEnabled: boolean;
  slowModeOnRaidEnabled: boolean;
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
};



export type ChatBotConfigAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "enabled" | "greetingEnabled" | "greetingMessage" | "commandPrefix" | "aiChatEnabled" | "aiPersonality" | "aiBotName" | "aiProvider" | "autoShoutoutEnabled" | "linkProtectionEnabled" | "slowModeOnRaidEnabled" | "insertedAt" | "updatedAt";
  id: UUID;
  enabled: boolean;
  greetingEnabled: boolean;
  greetingMessage: string;
  commandPrefix: string;
  aiChatEnabled: boolean;
  aiPersonality: string | null;
  aiBotName: string;
  aiProvider: string;
  autoShoutoutEnabled: boolean;
  linkProtectionEnabled: boolean;
  slowModeOnRaidEnabled: boolean;
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
};


// StreamAction Schema
export type StreamActionResourceSchema = {
  __type: "Resource";
  __primitiveFields: never;
};



export type StreamActionAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: never;
};


export type StreamActionInputSchema = {

};


// User Schema
export type UserResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "name" | "extraData" | "confirmedAt" | "emailNotifications" | "minDonationAmount" | "maxDonationAmount" | "donationCurrency" | "defaultVoice" | "avatarUrl" | "languagePreference" | "avatarFileId" | "tier" | "role" | "displayAvatar" | "isModerator" | "hoursStreamedLast30Days" | "storageQuota" | "storageUsedPercent";
  id: UUID;
  email: string;
  name: string;
  extraData: Record<string, any> | null;
  confirmedAt: UtcDateTimeUsec | null;
  emailNotifications: boolean;
  minDonationAmount: number | null;
  maxDonationAmount: number | null;
  donationCurrency: string;
  defaultVoice: string | null;
  avatarUrl: string | null;
  languagePreference: string | null;
  avatarFileId: UUID | null;
  tier: string | null;
  role: string | null;
  displayAvatar: string | null;
  isModerator: boolean | null;
  hoursStreamedLast30Days: number | null;
  storageQuota: number | null;
  storageUsedPercent: number | null;
};



export type UserAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "name" | "extraData" | "confirmedAt" | "emailNotifications" | "minDonationAmount" | "maxDonationAmount" | "donationCurrency" | "defaultVoice" | "avatarUrl" | "languagePreference" | "avatarFileId";
  id: UUID;
  email: string;
  name: string;
  extraData: Record<string, any> | null;
  confirmedAt: UtcDateTimeUsec | null;
  emailNotifications: boolean;
  minDonationAmount: number | null;
  maxDonationAmount: number | null;
  donationCurrency: string;
  defaultVoice: string | null;
  avatarUrl: string | null;
  languagePreference: string | null;
  avatarFileId: UUID | null;
};


// UserRole Schema
export type UserRoleResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "granterId" | "roleType" | "roleStatus" | "grantedAt" | "acceptedAt" | "revokedAt";
  id: UUID;
  userId: UUID;
  granterId: UUID;
  roleType: "moderator" | "manager";
  roleStatus: "pending" | "accepted" | "declined";
  grantedAt: UtcDateTimeUsec;
  acceptedAt: UtcDateTimeUsec | null;
  revokedAt: UtcDateTimeUsec | null;
};



export type UserRoleAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "granterId" | "roleType" | "roleStatus" | "grantedAt" | "acceptedAt" | "revokedAt";
  id: UUID;
  userId: UUID;
  granterId: UUID;
  roleType: "moderator" | "manager";
  roleStatus: "pending" | "accepted" | "declined";
  grantedAt: UtcDateTimeUsec;
  acceptedAt: UtcDateTimeUsec | null;
  revokedAt: UtcDateTimeUsec | null;
};


// WidgetConfig Schema
export type WidgetConfigResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "type" | "config";
  id: UUID;
  userId: UUID;
  type: string;
  config: Record<string, any>;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



export type WidgetConfigAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "type" | "config";
  id: UUID;
  userId: UUID;
  type: string;
  config: Record<string, any>;
};


// StreamingAccount Schema
export type StreamingAccountResourceSchema = {
  __type: "Resource";
  __primitiveFields: never;
};



export type StreamingAccountAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: never;
};


// SmartCanvasLayout Schema
export type SmartCanvasLayoutResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "widgets";
  id: UUID;
  userId: UUID;
  widgets: Array<Record<string, any>>;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



export type SmartCanvasLayoutAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "widgets";
  id: UUID;
  userId: UUID;
  widgets: Array<Record<string, any>>;
};


// LiveInput Schema
export type LiveInputResourceSchema = {
  __type: "Resource";
  __primitiveFields: "userId" | "orientation" | "data";
  userId: UUID;
  orientation: "horizontal" | "vertical";
  data: Record<string, any>;
};



export type LiveInputAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "userId" | "orientation" | "data";
  userId: UUID;
  orientation: "horizontal" | "vertical";
  data: Record<string, any>;
};


// DiscordWebhook Schema
export type DiscordWebhookResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id";
  id: UUID;
};



export type DiscordWebhookAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id";
  id: UUID;
};


// DiscordActor Schema
export type DiscordActorResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "type" | "data" | "status";
  id: UUID;
  type: string;
  data: Record<string, any>;
  status: "active" | "paused" | "terminated";
};



export type DiscordActorAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "type" | "data" | "status";
  id: UUID;
  type: string;
  data: Record<string, any>;
  status: "active" | "paused" | "terminated";
};


// IFTTTWebhook Schema
export type IFTTTWebhookResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id";
  id: UUID;
};



export type IFTTTWebhookAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id";
  id: UUID;
};


// Notification Schema
export type NotificationResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "content" | "contentDe" | "contentPl" | "contentEs" | "insertedAt";
  id: UUID;
  userId: UUID | null;
  content: string;
  contentDe: string | null;
  contentPl: string | null;
  contentEs: string | null;
  insertedAt: UtcDateTimeUsec;
  user: { __type: "Relationship"; __resource: UserResourceSchema | null; };
  reads: { __type: "Relationship"; __array: true; __resource: NotificationReadResourceSchema; };
};



export type NotificationAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "content" | "contentDe" | "contentPl" | "contentEs" | "insertedAt";
  id: UUID;
  userId: UUID | null;
  content: string;
  contentDe: string | null;
  contentPl: string | null;
  contentEs: string | null;
  insertedAt: UtcDateTimeUsec;
};


// NotificationRead Schema
export type NotificationReadResourceSchema = {
  __type: "Resource";
  __primitiveFields: "userId" | "notificationId" | "seenAt";
  userId: UUID;
  notificationId: UUID;
  seenAt: UtcDateTimeUsec;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
  notification: { __type: "Relationship"; __resource: NotificationResourceSchema; };
};



export type NotificationReadAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "userId" | "notificationId" | "seenAt";
  userId: UUID;
  notificationId: UUID;
  seenAt: UtcDateTimeUsec;
};


// File Schema
export type FileResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "url" | "uploadUrl" | "uploadHeaders" | "maxSize";
  id: UUID;
  url: string | null;
  uploadUrl: string | null;
  uploadHeaders: Array<Record<string, any>> | null;
  maxSize: number | null;
};



export type FileAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id";
  id: UUID;
};


// SupportTicket Schema
export type SupportTicketResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "subject" | "status" | "ticketType" | "insertedAt" | "updatedAt" | "userId";
  id: UUID;
  subject: string;
  status: "open" | "resolved";
  ticketType: "support" | "feature_request" | "bug_report";
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
  userId: UUID;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
  messages: { __type: "Relationship"; __array: true; __resource: SupportMessageResourceSchema; };
};



export type SupportTicketAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "subject" | "status" | "ticketType" | "insertedAt" | "updatedAt" | "userId";
  id: UUID;
  subject: string;
  status: "open" | "resolved";
  ticketType: "support" | "feature_request" | "bug_report";
  insertedAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
  userId: UUID;
};


// SupportMessage Schema
export type SupportMessageResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "content" | "insertedAt" | "ticketId" | "userId";
  id: UUID;
  content: string;
  insertedAt: UtcDateTimeUsec;
  ticketId: UUID;
  userId: UUID;
  ticket: { __type: "Relationship"; __resource: SupportTicketResourceSchema; };
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



export type SupportMessageAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "content" | "insertedAt" | "ticketId" | "userId";
  id: UUID;
  content: string;
  insertedAt: UtcDateTimeUsec;
  ticketId: UUID;
  userId: UUID;
};


// StreampaiStreamEventDataChatMessageData Schema
export type StreampaiStreamEventDataChatMessageDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "message" | "username" | "senderChannelId" | "isModerator" | "isPatreon" | "isSentByStreamer" | "deliveryStatus" | "emotes";
  message: string;
  username: string;
  senderChannelId: string | null;
  isModerator: boolean | null;
  isPatreon: boolean | null;
  isSentByStreamer: boolean | null;
  deliveryStatus: Record<string, any> | null;
  emotes: Array<Record<string, any>> | null;
};



export type StreampaiStreamEventDataChatMessageDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "message" | "username" | "senderChannelId" | "isModerator" | "isPatreon" | "isSentByStreamer" | "deliveryStatus" | "emotes";
  message: string;
  username: string;
  senderChannelId: string | null;
  isModerator: boolean | null;
  isPatreon: boolean | null;
  isSentByStreamer: boolean | null;
  deliveryStatus: Record<string, any> | null;
  emotes: Array<Record<string, any>> | null;
};


export type StreampaiStreamEventDataChatMessageDataInputSchema = {
  message: string;
  username: string;
  senderChannelId?: string | null;
  isModerator?: boolean | null;
  isPatreon?: boolean | null;
  isSentByStreamer?: boolean | null;
  deliveryStatus?: Record<string, any> | null;
  emotes?: Array<Record<string, any>> | null;
};


// StreampaiStreamEventDataDonationData Schema
export type StreampaiStreamEventDataDonationDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "donorName" | "amount" | "currency" | "message" | "platformDonationId" | "username" | "channelId" | "amountMicros" | "amountCents" | "comment" | "metadata";
  donorName: string;
  amount: string;
  currency: string;
  message: string | null;
  platformDonationId: string | null;
  username: string | null;
  channelId: string | null;
  amountMicros: string | null;
  amountCents: number | null;
  comment: string | null;
  metadata: Record<string, any> | null;
};



export type StreampaiStreamEventDataDonationDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "donorName" | "amount" | "currency" | "message" | "platformDonationId" | "username" | "channelId" | "amountMicros" | "amountCents" | "comment" | "metadata";
  donorName: string;
  amount: string;
  currency: string;
  message: string | null;
  platformDonationId: string | null;
  username: string | null;
  channelId: string | null;
  amountMicros: string | null;
  amountCents: number | null;
  comment: string | null;
  metadata: Record<string, any> | null;
};


export type StreampaiStreamEventDataDonationDataInputSchema = {
  donorName: string;
  amount: string;
  currency: string;
  message?: string | null;
  platformDonationId?: string | null;
  username?: string | null;
  channelId?: string | null;
  amountMicros?: string | null;
  amountCents?: number | null;
  comment?: string | null;
  metadata?: Record<string, any> | null;
};


// StreampaiStreamEventDataFollowData Schema
export type StreampaiStreamEventDataFollowDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "username" | "displayName";
  username: string;
  displayName: string | null;
};



export type StreampaiStreamEventDataFollowDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "username" | "displayName";
  username: string;
  displayName: string | null;
};


export type StreampaiStreamEventDataFollowDataInputSchema = {
  username: string;
  displayName?: string | null;
};


// StreampaiStreamEventDataSubscriptionData Schema
export type StreampaiStreamEventDataSubscriptionDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "username" | "tier" | "months" | "message" | "channelId" | "metadata";
  username: string;
  tier: string;
  months: string | null;
  message: string | null;
  channelId: string | null;
  metadata: Record<string, any> | null;
};



export type StreampaiStreamEventDataSubscriptionDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "username" | "tier" | "months" | "message" | "channelId" | "metadata";
  username: string;
  tier: string;
  months: string | null;
  message: string | null;
  channelId: string | null;
  metadata: Record<string, any> | null;
};


export type StreampaiStreamEventDataSubscriptionDataInputSchema = {
  username: string;
  tier: string;
  months?: string | null;
  message?: string | null;
  channelId?: string | null;
  metadata?: Record<string, any> | null;
};


// StreampaiStreamEventDataRaidData Schema
export type StreampaiStreamEventDataRaidDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "raiderName" | "viewerCount" | "message";
  raiderName: string;
  viewerCount: string;
  message: string | null;
};



export type StreampaiStreamEventDataRaidDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "raiderName" | "viewerCount" | "message";
  raiderName: string;
  viewerCount: string;
  message: string | null;
};


export type StreampaiStreamEventDataRaidDataInputSchema = {
  raiderName: string;
  viewerCount: string;
  message?: string | null;
};


// StreampaiStreamEventDataStreamUpdatedData Schema
export type StreampaiStreamEventDataStreamUpdatedDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "username" | "title" | "description" | "thumbnailUrl" | "user";
  username: string | null;
  title: string | null;
  description: string | null;
  thumbnailUrl: string | null;
  user: Record<string, any> | null;
};



export type StreampaiStreamEventDataStreamUpdatedDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "username" | "title" | "description" | "thumbnailUrl" | "user";
  username: string | null;
  title: string | null;
  description: string | null;
  thumbnailUrl: string | null;
  user: Record<string, any> | null;
};


export type StreampaiStreamEventDataStreamUpdatedDataInputSchema = {
  username?: string | null;
  title?: string | null;
  description?: string | null;
  thumbnailUrl?: string | null;
  user?: Record<string, any> | null;
};


// StreampaiStreamEventDataPlatformEventData Schema
export type StreampaiStreamEventDataPlatformEventDataResourceSchema = {
  __type: "Resource";
  __primitiveFields: "platform";
  platform: string;
};



export type StreampaiStreamEventDataPlatformEventDataAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "platform";
  platform: string;
};


export type StreampaiStreamEventDataPlatformEventDataInputSchema = {
  platform: string;
};




export type LivestreamFilterInput = {
  and?: Array<LivestreamFilterInput>;
  or?: Array<LivestreamFilterInput>;
  not?: Array<LivestreamFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  category?: {
    eq?: "gaming" | "music" | "tech" | "art" | "talk" | "irl" | "just_chatting";
    notEq?: "gaming" | "music" | "tech" | "art" | "talk" | "irl" | "just_chatting";
    in?: Array<"gaming" | "music" | "tech" | "art" | "talk" | "irl" | "just_chatting">;
  };

  subcategory?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  language?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  tags?: {
    eq?: Array<string>;
    notEq?: Array<string>;
    in?: Array<Array<string>>;
  };

  thumbnailUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  thumbnailFileId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  startedAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  endedAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  averageViewers?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  peakViewers?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  messagesAmount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  durationSeconds?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  platforms?: {
    eq?: Array<string>;
    notEq?: Array<string>;
    in?: Array<Array<string>>;
  };


  user?: UserFilterInput;

  thumbnailFile?: FileFilterInput;

  streamEvents?: StreamEventFilterInput;

};
export type StreamEventFilterInput = {
  and?: Array<StreamEventFilterInput>;
  or?: Array<StreamEventFilterInput>;
  not?: Array<StreamEventFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  type?: {
    eq?: "chat_message" | "donation" | "follow" | "raid" | "subscription" | "stream_updated" | "platform_started" | "platform_stopped";
    notEq?: "chat_message" | "donation" | "follow" | "raid" | "subscription" | "stream_updated" | "platform_started" | "platform_stopped";
    in?: Array<"chat_message" | "donation" | "follow" | "raid" | "subscription" | "stream_updated" | "platform_started" | "platform_stopped">;
  };

  data?: {
    eq?: { __type: "Union"; __primitiveFields: never; chatMessage?: StreampaiStreamEventDataChatMessageDataResourceSchema; donation?: StreampaiStreamEventDataDonationDataResourceSchema; follow?: StreampaiStreamEventDataFollowDataResourceSchema; subscription?: StreampaiStreamEventDataSubscriptionDataResourceSchema; raid?: StreampaiStreamEventDataRaidDataResourceSchema; streamUpdated?: StreampaiStreamEventDataStreamUpdatedDataResourceSchema; platformStarted?: StreampaiStreamEventDataPlatformEventDataResourceSchema; platformStopped?: StreampaiStreamEventDataPlatformEventDataResourceSchema; };
    notEq?: { __type: "Union"; __primitiveFields: never; chatMessage?: StreampaiStreamEventDataChatMessageDataResourceSchema; donation?: StreampaiStreamEventDataDonationDataResourceSchema; follow?: StreampaiStreamEventDataFollowDataResourceSchema; subscription?: StreampaiStreamEventDataSubscriptionDataResourceSchema; raid?: StreampaiStreamEventDataRaidDataResourceSchema; streamUpdated?: StreampaiStreamEventDataStreamUpdatedDataResourceSchema; platformStarted?: StreampaiStreamEventDataPlatformEventDataResourceSchema; platformStopped?: StreampaiStreamEventDataPlatformEventDataResourceSchema; };
    in?: Array<{ __type: "Union"; __primitiveFields: never; chatMessage?: StreampaiStreamEventDataChatMessageDataResourceSchema; donation?: StreampaiStreamEventDataDonationDataResourceSchema; follow?: StreampaiStreamEventDataFollowDataResourceSchema; subscription?: StreampaiStreamEventDataSubscriptionDataResourceSchema; raid?: StreampaiStreamEventDataRaidDataResourceSchema; streamUpdated?: StreampaiStreamEventDataStreamUpdatedDataResourceSchema; platformStarted?: StreampaiStreamEventDataPlatformEventDataResourceSchema; platformStopped?: StreampaiStreamEventDataPlatformEventDataResourceSchema; }>;
  };

  authorId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  livestreamId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  platform?: {
    eq?: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
    notEq?: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
    in?: Array<"youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble">;
  };

  viewerId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  wasDisplayed?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };



};
export type StreamViewerFilterInput = {
  and?: Array<StreamViewerFilterInput>;
  or?: Array<StreamViewerFilterInput>;
  not?: Array<StreamViewerFilterInput>;

  viewerId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  platform?: {
    eq?: "twitch" | "youtube" | "facebook" | "kick";
    notEq?: "twitch" | "youtube" | "facebook" | "kick";
    in?: Array<"twitch" | "youtube" | "facebook" | "kick">;
  };

  displayName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  avatarUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  channelUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isVerified?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  isOwner?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  isModerator?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  isPatreon?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  notes?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  aiSummary?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  firstSeenAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  lastSeenAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };



};
export type BannedViewerFilterInput = {
  and?: Array<BannedViewerFilterInput>;
  or?: Array<BannedViewerFilterInput>;
  not?: Array<BannedViewerFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  platform?: {
    eq?: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
    notEq?: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
    in?: Array<"youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble">;
  };

  viewerUsername?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  viewerPlatformId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  reason?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  durationSeconds?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  expiresAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  isActive?: {
    eq?: boolean;
    notEq?: boolean;
  };

  platformBanId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  unbannedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  updatedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };



};
export type CurrentStreamDataFilterInput = {
  and?: Array<CurrentStreamDataFilterInput>;
  or?: Array<CurrentStreamDataFilterInput>;
  not?: Array<CurrentStreamDataFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  status?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  streamData?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  cloudflareData?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  youtubeData?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  twitchData?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  kickData?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  activeAlert?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  highlightedMessage?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  alertboxState?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };



};
export type StreamTimerFilterInput = {
  and?: Array<StreamTimerFilterInput>;
  or?: Array<StreamTimerFilterInput>;
  not?: Array<StreamTimerFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  label?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  intervalSeconds?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  disabledAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  updatedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };



};
export type HighlightedMessageFilterInput = {
  and?: Array<HighlightedMessageFilterInput>;
  or?: Array<HighlightedMessageFilterInput>;
  not?: Array<HighlightedMessageFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  chatMessageId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  message?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  senderUsername?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  senderChannelId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  platform?: {
    eq?: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
    notEq?: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
    in?: Array<"youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble">;
  };

  viewerId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  highlightedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  user?: UserFilterInput;

};
export type ChatBotConfigFilterInput = {
  and?: Array<ChatBotConfigFilterInput>;
  or?: Array<ChatBotConfigFilterInput>;
  not?: Array<ChatBotConfigFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  enabled?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  greetingEnabled?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  greetingMessage?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  commandPrefix?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  aiChatEnabled?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  aiPersonality?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  aiBotName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  aiProvider?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  autoShoutoutEnabled?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  linkProtectionEnabled?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  slowModeOnRaidEnabled?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  updatedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };



};
export type StreamActionFilterInput = {
  and?: Array<StreamActionFilterInput>;
  or?: Array<StreamActionFilterInput>;
  not?: Array<StreamActionFilterInput>;




};
export type UserFilterInput = {
  and?: Array<UserFilterInput>;
  or?: Array<UserFilterInput>;
  not?: Array<UserFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  extraData?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  confirmedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  emailNotifications?: {
    eq?: boolean;
    notEq?: boolean;
    in?: Array<boolean>;
  };

  minDonationAmount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  maxDonationAmount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  donationCurrency?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  defaultVoice?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  avatarUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  languagePreference?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  avatarFileId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  tier?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  role?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  displayAvatar?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isModerator?: {
    eq?: boolean;
    notEq?: boolean;
  };

  hoursStreamedLast30Days?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  storageQuota?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  storageUsedPercent?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };



};
export type UserRoleFilterInput = {
  and?: Array<UserRoleFilterInput>;
  or?: Array<UserRoleFilterInput>;
  not?: Array<UserRoleFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  granterId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  roleType?: {
    eq?: "moderator" | "manager";
    notEq?: "moderator" | "manager";
    in?: Array<"moderator" | "manager">;
  };

  roleStatus?: {
    eq?: "pending" | "accepted" | "declined";
    notEq?: "pending" | "accepted" | "declined";
    in?: Array<"pending" | "accepted" | "declined">;
  };

  grantedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  acceptedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  revokedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };



};
export type WidgetConfigFilterInput = {
  and?: Array<WidgetConfigFilterInput>;
  or?: Array<WidgetConfigFilterInput>;
  not?: Array<WidgetConfigFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  type?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  config?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };


  user?: UserFilterInput;

};
export type StreamingAccountFilterInput = {
  and?: Array<StreamingAccountFilterInput>;
  or?: Array<StreamingAccountFilterInput>;
  not?: Array<StreamingAccountFilterInput>;




};
export type SmartCanvasLayoutFilterInput = {
  and?: Array<SmartCanvasLayoutFilterInput>;
  or?: Array<SmartCanvasLayoutFilterInput>;
  not?: Array<SmartCanvasLayoutFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  widgets?: {
    eq?: Array<Record<string, any>>;
    notEq?: Array<Record<string, any>>;
    in?: Array<Array<Record<string, any>>>;
  };


  user?: UserFilterInput;

};
export type LiveInputFilterInput = {
  and?: Array<LiveInputFilterInput>;
  or?: Array<LiveInputFilterInput>;
  not?: Array<LiveInputFilterInput>;

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  orientation?: {
    eq?: "horizontal" | "vertical";
    notEq?: "horizontal" | "vertical";
    in?: Array<"horizontal" | "vertical">;
  };

  data?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };



};
export type DiscordWebhookFilterInput = {
  and?: Array<DiscordWebhookFilterInput>;
  or?: Array<DiscordWebhookFilterInput>;
  not?: Array<DiscordWebhookFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};
export type DiscordActorFilterInput = {
  and?: Array<DiscordActorFilterInput>;
  or?: Array<DiscordActorFilterInput>;
  not?: Array<DiscordActorFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  type?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  data?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  status?: {
    eq?: "active" | "paused" | "terminated";
    notEq?: "active" | "paused" | "terminated";
    in?: Array<"active" | "paused" | "terminated">;
  };



};
export type IFTTTWebhookFilterInput = {
  and?: Array<IFTTTWebhookFilterInput>;
  or?: Array<IFTTTWebhookFilterInput>;
  not?: Array<IFTTTWebhookFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };



};
export type NotificationFilterInput = {
  and?: Array<NotificationFilterInput>;
  or?: Array<NotificationFilterInput>;
  not?: Array<NotificationFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  contentDe?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  contentPl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  contentEs?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };


  user?: UserFilterInput;

  reads?: NotificationReadFilterInput;

};
export type NotificationReadFilterInput = {
  and?: Array<NotificationReadFilterInput>;
  or?: Array<NotificationReadFilterInput>;
  not?: Array<NotificationReadFilterInput>;

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  notificationId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  seenAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };


  user?: UserFilterInput;

  notification?: NotificationFilterInput;

};
export type FileFilterInput = {
  and?: Array<FileFilterInput>;
  or?: Array<FileFilterInput>;
  not?: Array<FileFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  url?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  uploadUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  uploadHeaders?: {
    eq?: Array<Record<string, any>>;
    notEq?: Array<Record<string, any>>;
    in?: Array<Array<Record<string, any>>>;
  };

  maxSize?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };



};
export type SupportTicketFilterInput = {
  and?: Array<SupportTicketFilterInput>;
  or?: Array<SupportTicketFilterInput>;
  not?: Array<SupportTicketFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  subject?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  status?: {
    eq?: "open" | "resolved";
    notEq?: "open" | "resolved";
    in?: Array<"open" | "resolved">;
  };

  ticketType?: {
    eq?: "support" | "feature_request" | "bug_report";
    notEq?: "support" | "feature_request" | "bug_report";
    in?: Array<"support" | "feature_request" | "bug_report">;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  updatedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  user?: UserFilterInput;

  messages?: SupportMessageFilterInput;

};
export type SupportMessageFilterInput = {
  and?: Array<SupportMessageFilterInput>;
  or?: Array<SupportMessageFilterInput>;
  not?: Array<SupportMessageFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  ticketId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  ticket?: SupportTicketFilterInput;

  user?: UserFilterInput;

};
export type StreampaiStreamEventDataChatMessageDataFilterInput = {
  and?: Array<StreampaiStreamEventDataChatMessageDataFilterInput>;
  or?: Array<StreampaiStreamEventDataChatMessageDataFilterInput>;
  not?: Array<StreampaiStreamEventDataChatMessageDataFilterInput>;

  message?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  username?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  senderChannelId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isModerator?: {
    eq?: boolean;
    notEq?: boolean;
  };

  isPatreon?: {
    eq?: boolean;
    notEq?: boolean;
  };

  isSentByStreamer?: {
    eq?: boolean;
    notEq?: boolean;
  };

  deliveryStatus?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  emotes?: {
    eq?: Array<Record<string, any>>;
    notEq?: Array<Record<string, any>>;
    in?: Array<Array<Record<string, any>>>;
  };



};
export type StreampaiStreamEventDataDonationDataFilterInput = {
  and?: Array<StreampaiStreamEventDataDonationDataFilterInput>;
  or?: Array<StreampaiStreamEventDataDonationDataFilterInput>;
  not?: Array<StreampaiStreamEventDataDonationDataFilterInput>;

  donorName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  amount?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  currency?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  message?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  platformDonationId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  username?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  channelId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  amountMicros?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  amountCents?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  comment?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  metadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };



};
export type StreampaiStreamEventDataFollowDataFilterInput = {
  and?: Array<StreampaiStreamEventDataFollowDataFilterInput>;
  or?: Array<StreampaiStreamEventDataFollowDataFilterInput>;
  not?: Array<StreampaiStreamEventDataFollowDataFilterInput>;

  username?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  displayName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};
export type StreampaiStreamEventDataSubscriptionDataFilterInput = {
  and?: Array<StreampaiStreamEventDataSubscriptionDataFilterInput>;
  or?: Array<StreampaiStreamEventDataSubscriptionDataFilterInput>;
  not?: Array<StreampaiStreamEventDataSubscriptionDataFilterInput>;

  username?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  tier?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  months?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  message?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  channelId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  metadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };



};
export type StreampaiStreamEventDataRaidDataFilterInput = {
  and?: Array<StreampaiStreamEventDataRaidDataFilterInput>;
  or?: Array<StreampaiStreamEventDataRaidDataFilterInput>;
  not?: Array<StreampaiStreamEventDataRaidDataFilterInput>;

  raiderName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  viewerCount?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  message?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};
export type StreampaiStreamEventDataStreamUpdatedDataFilterInput = {
  and?: Array<StreampaiStreamEventDataStreamUpdatedDataFilterInput>;
  or?: Array<StreampaiStreamEventDataStreamUpdatedDataFilterInput>;
  not?: Array<StreampaiStreamEventDataStreamUpdatedDataFilterInput>;

  username?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  thumbnailUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  user?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };



};
export type StreampaiStreamEventDataPlatformEventDataFilterInput = {
  and?: Array<StreampaiStreamEventDataPlatformEventDataFilterInput>;
  or?: Array<StreampaiStreamEventDataPlatformEventDataFilterInput>;
  not?: Array<StreampaiStreamEventDataPlatformEventDataFilterInput>;

  platform?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};


// Utility Types

// Resource schema constraint
export type TypedSchema = {
  __type: "Resource" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

// Helper type to infer union field values, avoiding duplication between array and non-array unions
export type InferUnionFieldValue<
  UnionSchema extends { __type: "Union"; __primitiveFields: any },
  FieldSelection extends any[],
> = UnionToIntersection<
  {
    [FieldIndex in keyof FieldSelection]: FieldSelection[FieldIndex] extends UnionSchema["__primitiveFields"]
      ? FieldSelection[FieldIndex] extends keyof UnionSchema
        ? { [P in FieldSelection[FieldIndex]]: UnionSchema[FieldSelection[FieldIndex]] }
        : never
      : FieldSelection[FieldIndex] extends Record<string, any>
        ? {
            [UnionKey in keyof FieldSelection[FieldIndex]]: UnionKey extends keyof UnionSchema
              ? NonNullable<UnionSchema[UnionKey]> extends { __array: true; __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                ? FieldSelection[FieldIndex][UnionKey] extends any[]
                  ? Array<
                      UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof NonNullable<UnionSchema[UnionKey]>
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: NonNullable<UnionSchema[UnionKey]>[P] }
                              : never
                            : never;
                        }[number]
                      >
                    > | null
                  : never
                : NonNullable<UnionSchema[UnionKey]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                  ? FieldSelection[FieldIndex][UnionKey] extends any[]
                    ? UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof NonNullable<UnionSchema[UnionKey]>
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: NonNullable<UnionSchema[UnionKey]>[P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : never
                  : NonNullable<UnionSchema[UnionKey]> extends TypedSchema
                    ? InferResult<NonNullable<UnionSchema[UnionKey]>, FieldSelection[FieldIndex][UnionKey]>
                    : never
              : never;
          }
        : never;
  }[number]
>;

export type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

export type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

export type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

export type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : T[K] extends { __type: "TypedMap" }
        ? NonNullable<T[K]> extends TypedSchema
          ? UnifiedFieldSelection<NonNullable<T[K]>>[]
          : never
        : T[K] extends { __type: "Union"; __primitiveFields: infer PrimitiveFields }
          ? T[K] extends { __array: true }
            ? (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields" | "__array">]?: NonNullable<T[K][UnionKey]> extends { __type: "TypedMap"; __primitiveFields: any }
                  ? NonNullable<T[K][UnionKey]>["__primitiveFields"][]
                  : NonNullable<T[K][UnionKey]> extends TypedSchema
                    ? UnifiedFieldSelection<NonNullable<T[K][UnionKey]>>[]
                    : never;
              })[]
            : (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields">]?: NonNullable<T[K][UnionKey]> extends { __type: "TypedMap"; __primitiveFields: any }
                  ? NonNullable<T[K][UnionKey]>["__primitiveFields"][]
                  : NonNullable<T[K][UnionKey]> extends TypedSchema
                    ? UnifiedFieldSelection<NonNullable<T[K][UnionKey]>>[]
                    : never;
              })[]
            : NonNullable<T[K]> extends TypedSchema
              ? UnifiedFieldSelection<NonNullable<T[K]>>[]
              : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
export type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

export type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
              ? NonNullable<T[K]> extends { __array: true }
                ? Field[K] extends any[]
                  ? null extends T[K]
                    ? Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                              ? E extends TypedMapFields
                                ? E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                                : E extends Record<string, any>
                                  ? {
                                      [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                        ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                          ? null extends NonNullable<T[K]>[NestedKey]
                                            ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                            : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                          : never
                                        : never;
                                    }
                                  : E extends keyof NonNullable<T[K]>
                                    ? { [P in E]: NonNullable<T[K]>[P] }
                                    : never
                              : never;
                          }[number]
                        >
                      > | null
                    : Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                              ? E extends TypedMapFields
                                ? E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                                : E extends Record<string, any>
                                  ? {
                                      [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                        ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                          ? null extends NonNullable<T[K]>[NestedKey]
                                            ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                            : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                          : never
                                        : never;
                                    }
                                  : E extends keyof NonNullable<T[K]>
                                    ? { [P in E]: NonNullable<T[K]>[P] }
                                    : never
                              : never;
                          }[number]
                        >
                      >
                  : never
                : Field[K] extends any[]
                  ? null extends T[K]
                    ? UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                            ? E extends TypedMapFields
                              ? E extends keyof NonNullable<T[K]>
                                ? { [P in E]: NonNullable<T[K]>[P] }
                                : never
                              : E extends Record<string, any>
                                ? {
                                    [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                      ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                        ? null extends NonNullable<T[K]>[NestedKey]
                                          ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                          : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                        : never
                                      : never;
                                  }
                                : E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                            : never;
                        }[number]
                      > | null
                    : UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                            ? E extends TypedMapFields
                              ? E extends keyof T[K]
                                ? { [P in E]: T[K][P] }
                                : never
                              : E extends Record<string, any>
                                ? {
                                    [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                      ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                        ? null extends NonNullable<T[K]>[NestedKey]
                                          ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                          : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                        : never
                                      : never;
                                  }
                                : E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                            : never;
                        }[number]
                      >
                  : never
              : T[K] extends { __type: "Union"; __primitiveFields: any }
                ? T[K] extends { __array: true }
                  ? Field[K] extends any[]
                    ? null extends T[K]
                      ? Array<InferUnionFieldValue<T[K], Field[K]>> | null
                      : Array<InferUnionFieldValue<T[K], Field[K]>>
                    : never
                  : Field[K] extends any[]
                    ? null extends T[K]
                      ? InferUnionFieldValue<T[K], Field[K]> | null
                      : InferUnionFieldValue<T[K], Field[K]>
                    : never
                  : NonNullable<T[K]> extends TypedSchema
                    ? null extends T[K]
                      ? InferResult<NonNullable<T[K]>, Field[K]> | null
                      : InferResult<NonNullable<T[K]>, Field[K]>
                    : never
          : never;
      }
    : never;

export type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[] | undefined,
> = SelectedFields extends undefined
  ? {}
  : SelectedFields extends []
  ? {}
  : SelectedFields extends UnifiedFieldSelection<T>[]
  ? UnionToIntersection<
      {
        [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
      }[number]
    >
  : {};

// Pagination conditional types
// Checks if a page configuration object has any pagination parameters
export type HasPaginationParams<Page> =
  Page extends { offset: any } ? true :
  Page extends { after: any } ? true :
  Page extends { before: any } ? true :
  false;

// Infer which pagination type is being used from the page config
export type InferPaginationType<Page> =
  Page extends { offset: any } ? "offset" :
  Page extends { after: any } | { before: any } ? "keyset" :
  never;

// Returns either non-paginated (array) or paginated result based on page params
// For single pagination type support (offset-only or keyset-only)
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export type ConditionalPaginatedResult<
  Page,
  RecordType,
  PaginatedType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? PaginatedType
    : RecordType;

// For actions supporting both offset and keyset pagination
// Infers the specific pagination type based on which params were passed
export type ConditionalPaginatedResultMixed<
  Page,
  RecordType,
  OffsetType,
  KeysetType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? InferPaginationType<Page> extends "offset"
      ? OffsetType
      : InferPaginationType<Page> extends "keyset"
        ? KeysetType
        : OffsetType | KeysetType  // Fallback to union if can't determine
    : RecordType;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call.
 *
 * This type matches the error structure defined in the AshTypescript.Rpc.Error protocol.
 *
 * @example
 * const error: AshRpcError = {
 *   type: "invalid_changes",
 *   message: "Invalid value for field %{field}",
 *   shortMessage: "Invalid changes",
 *   vars: { field: "email" },
 *   fields: ["email"],
 *   path: ["user", "email"],
 *   details: { suggestion: "Provide a valid email address" }
 * }
 */
export type AshRpcError = {
  /** Machine-readable error type (e.g., "invalid_changes", "not_found") */
  type: string;
  /** Full error message (may contain template variables like %{key}) */
  message: string;
  /** Concise version of the message */
  shortMessage: string;
  /** Variables to interpolate into the message template */
  vars: Record<string, any>;
  /** List of affected field names (for field-level errors) */
  fields: string[];
  /** Path to the error location in the data structure */
  path: string[];
  /** Optional map with extra details (e.g., suggestions, hints) */
  details?: Record<string, any>;
}

/**
 * Represents the result of a validation RPC call.
 *
 * All validation actions return this same structure, indicating either
 * successful validation or a list of validation errors.
 *
 * @example
 * // Successful validation
 * const result: ValidationResult = { success: true };
 *
 * // Failed validation
 * const result: ValidationResult = {
 *   success: false,
 *   errors: [
 *     {
 *       type: "required",
 *       message: "is required",
 *       shortMessage: "Required field",
 *       vars: { field: "email" },
 *       fields: ["email"],
 *       path: []
 *     }
 *   ]
 * };
 */
export type ValidationResult =
  | { success: true }
  | { success: false; errors: AshRpcError[]; };





// Helper Functions

/**
 * Configuration options for action RPC requests
 */
export interface ActionConfig {
  // Request data
  input?: Record<string, any>;
  identity?: any;
  fields?: Array<string | Record<string, any>>; // Field selection
  filter?: Record<string, any>; // Filter options (for reads)
  sort?: string; // Sort options
  page?:
    | {
        // Offset-based pagination
        limit?: number;
        offset?: number;
        count?: boolean;
      }
    | {
        // Keyset pagination
        limit?: number;
        after?: string;
        before?: string;
      };

  // Metadata
  metadataFields?: ReadonlyArray<string>;

  // HTTP customization
  headers?: Record<string, string>; // Custom headers
  fetchOptions?: RequestInit; // Fetch options (signal, cache, etc.)
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Multitenancy
  tenant?: string; // Tenant parameter

  // Hook context
  hookCtx?: Record<string, any>;
}


/**
 * Configuration options for action channel RPC requests
 */
export interface ActionChannelConfig {
  // Request data
  input?: Record<string, any>;
  identity?: any;
  fields?: ReadonlyArray<string | Record<string, any>>;
  filter?: Record<string, any>;
  sort?: string;
  page?:
    | {
        limit?: number;
        offset?: number;
        count?: boolean;
      }
    | {
        limit?: number;
        after?: string;
        before?: string;
      };

  // Metadata
  metadataFields?: ReadonlyArray<string>;

  // Channel-specific
  channel: any; // Phoenix Channel
  resultHandler: (result: any) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;

  // Multitenancy
  tenant?: string;

  // Hook context
  hookCtx?: Record<string, any>;
}



/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}

/**
 * Internal helper function for making action RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ActionConfig
 */
export async function executeActionRpcRequest<T>(
  payload: Record<string, any>,
  config: ActionConfig
): Promise<T> {
    let processedConfig = config;
    if (RpcHooks.beforeRequest) {
      processedConfig = await RpcHooks.beforeRequest(payload.action, config);
    }

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/api/rpc/run", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}




/**
 * Internal helper function for making action channel push requests
 * Handles hooks and channel push with receive handlers
 * @param config Configuration matching ActionChannelConfig
 */
export async function executeActionChannelPush<T>(
  channel: any,
  payload: Record<string, any>,
  timeout: number | undefined,
  config: ActionChannelConfig
) {
    const processedConfig = config;

  const effectiveTimeout = timeout;

  channel
    .push("run", payload, effectiveTimeout)
    .receive("ok", async (result: T) => {

      config.resultHandler(result);
    })
    .receive("error", async (error: any) => {

      (config.errorHandler
        ? config.errorHandler
        : (error: any) => {
            console.error(
              `An error occurred while running action ${payload.action}:`,
              error
            );
          })(error);
    })
    .receive("timeout", async () => {

      (config.timeoutHandler
        ? config.timeoutHandler
        : () => {
            console.error(`Timeout occurred while running action ${payload.action}`);
          })();
    });
}







export type GetStreamHistoryInput = {
  userId?: UUID;
};

export type GetStreamHistoryFields = UnifiedFieldSelection<LivestreamResourceSchema>[];
export type InferGetStreamHistoryResult<
  Fields extends GetStreamHistoryFields,
> = Array<InferResult<LivestreamResourceSchema, Fields>>;

export type GetStreamHistoryResult<Fields extends GetStreamHistoryFields> = | { success: true; data: InferGetStreamHistoryResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Livestream records
 *
 * @ashActionType :read
 */
export async function getStreamHistory<Fields extends GetStreamHistoryFields>(
  config: {
  tenant?: string;
  input?: GetStreamHistoryInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: LivestreamFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetStreamHistoryResult<Fields>> {
  const payload = {
    action: "get_stream_history",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetStreamHistoryResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read Livestream records
 *
 * @ashActionType :read
 */
export async function getStreamHistoryChannel<Fields extends GetStreamHistoryFields>(config: {
  channel: Channel;
  tenant?: string;
  input?: GetStreamHistoryInput;
  fields: Fields;
  filter?: LivestreamFilterInput;
  sort?: string;
  resultHandler: (result: GetStreamHistoryResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetStreamHistoryResult<Fields>>(
    config.channel,
    {
    action: "get_stream_history",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type GetLivestreamFields = UnifiedFieldSelection<LivestreamResourceSchema>[];
export type InferGetLivestreamResult<
  Fields extends GetLivestreamFields,
> = InferResult<LivestreamResourceSchema, Fields>;

export type GetLivestreamResult<Fields extends GetLivestreamFields> = | { success: true; data: InferGetLivestreamResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Livestream records
 *
 * @ashActionType :read
 */
export async function getLivestream<Fields extends GetLivestreamFields>(
  config: {
  tenant?: string;
  hookCtx?: ActionHookContext;
  getBy: {
    id: UUID;
  };
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetLivestreamResult<Fields>> {
  const payload = {
    action: "get_livestream",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    getBy: config.getBy,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetLivestreamResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read Livestream records
 *
 * @ashActionType :read
 */
export async function getLivestreamChannel<Fields extends GetLivestreamFields>(config: {
  channel: Channel;
  tenant?: string;
  getBy: {
    id: UUID;
  };
  fields: Fields;
  resultHandler: (result: GetLivestreamResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetLivestreamResult<Fields>>(
    config.channel,
    {
    action: "get_livestream",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    getBy: config.getBy,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetLivestreamEventsInput = {
  livestreamId: UUID;
};

export type GetLivestreamEventsFields = UnifiedFieldSelection<StreamEventResourceSchema>[];
export type InferGetLivestreamEventsResult<
  Fields extends GetLivestreamEventsFields,
> = Array<InferResult<StreamEventResourceSchema, Fields>>;

export type GetLivestreamEventsResult<Fields extends GetLivestreamEventsFields> = | { success: true; data: InferGetLivestreamEventsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getLivestreamEvents<Fields extends GetLivestreamEventsFields>(
  config: {
  tenant?: string;
  input: GetLivestreamEventsInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetLivestreamEventsResult<Fields>> {
  const payload = {
    action: "get_livestream_events",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetLivestreamEventsResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getLivestreamEventsChannel<Fields extends GetLivestreamEventsFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetLivestreamEventsInput;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  resultHandler: (result: GetLivestreamEventsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetLivestreamEventsResult<Fields>>(
    config.channel,
    {
    action: "get_livestream_events",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type GetViewerEventsInput = {
  viewerId: string;
  userId: UUID;
};

export type GetViewerEventsFields = UnifiedFieldSelection<StreamEventResourceSchema>[];
export type InferGetViewerEventsResult<
  Fields extends GetViewerEventsFields,
> = Array<InferResult<StreamEventResourceSchema, Fields>>;

export type GetViewerEventsResult<Fields extends GetViewerEventsFields> = | { success: true; data: InferGetViewerEventsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getViewerEvents<Fields extends GetViewerEventsFields>(
  config: {
  tenant?: string;
  input: GetViewerEventsInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetViewerEventsResult<Fields>> {
  const payload = {
    action: "get_viewer_events",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetViewerEventsResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getViewerEventsChannel<Fields extends GetViewerEventsFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetViewerEventsInput;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  resultHandler: (result: GetViewerEventsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetViewerEventsResult<Fields>>(
    config.channel,
    {
    action: "get_viewer_events",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type MarkStreamEventDisplayedFields = UnifiedFieldSelection<StreamEventResourceSchema>[];

export type InferMarkStreamEventDisplayedResult<
  Fields extends MarkStreamEventDisplayedFields | undefined,
> = InferResult<StreamEventResourceSchema, Fields>;

export type MarkStreamEventDisplayedResult<Fields extends MarkStreamEventDisplayedFields | undefined = undefined> = | { success: true; data: InferMarkStreamEventDisplayedResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing StreamEvent
 *
 * @ashActionType :update
 */
export async function markStreamEventDisplayed<Fields extends MarkStreamEventDisplayedFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MarkStreamEventDisplayedResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "mark_stream_event_displayed",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MarkStreamEventDisplayedResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing StreamEvent
 *
 * @ashActionType :update
 */
export async function markStreamEventDisplayedChannel<Fields extends MarkStreamEventDisplayedFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: MarkStreamEventDisplayedResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<MarkStreamEventDisplayedResult<Fields>>(
    config.channel,
    {
    action: "mark_stream_event_displayed",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetChatHistoryInput = {
  userId: UUID;
  platform?: string;
  dateRange?: string;
  search?: string;
};

export type GetChatHistoryFields = UnifiedFieldSelection<StreamEventResourceSchema>[];


export type InferGetChatHistoryResult<
  Fields extends GetChatHistoryFields | undefined,
  Page extends GetChatHistoryConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<StreamEventResourceSchema, Fields>>, {
  results: Array<InferResult<StreamEventResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type GetChatHistoryConfig = {
  tenant?: string;
  input: GetChatHistoryInput;
  hookCtx?: ActionHookContext;
  fields: GetChatHistoryFields;
  filter?: StreamEventFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type GetChatHistoryResult<Fields extends GetChatHistoryFields, Page extends GetChatHistoryConfig["page"] = undefined> = | { success: true; data: InferGetChatHistoryResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getChatHistory<Fields extends GetChatHistoryFields, Config extends GetChatHistoryConfig = GetChatHistoryConfig>(
  config: Config & { fields: Fields }
): Promise<GetChatHistoryResult<Fields, Config["page"]>> {
  const payload = {
    action: "get_chat_history",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<GetChatHistoryResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getChatHistoryChannel<Fields extends GetChatHistoryFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetChatHistoryInput;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  resultHandler: (result: GetChatHistoryResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetChatHistoryResult<Fields>>(
    config.channel,
    {
    action: "get_chat_history",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  },
    config.timeout,
    config
  );
}


export type GetLivestreamChatInput = {
  livestreamId: UUID;
};

export type GetLivestreamChatFields = UnifiedFieldSelection<StreamEventResourceSchema>[];
export type InferGetLivestreamChatResult<
  Fields extends GetLivestreamChatFields,
> = Array<InferResult<StreamEventResourceSchema, Fields>>;

export type GetLivestreamChatResult<Fields extends GetLivestreamChatFields> = | { success: true; data: InferGetLivestreamChatResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getLivestreamChat<Fields extends GetLivestreamChatFields>(
  config: {
  tenant?: string;
  input: GetLivestreamChatInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetLivestreamChatResult<Fields>> {
  const payload = {
    action: "get_livestream_chat",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetLivestreamChatResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getLivestreamChatChannel<Fields extends GetLivestreamChatFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetLivestreamChatInput;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  resultHandler: (result: GetLivestreamChatResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetLivestreamChatResult<Fields>>(
    config.channel,
    {
    action: "get_livestream_chat",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type GetViewerChatInput = {
  viewerId: string;
  userId: UUID;
};

export type GetViewerChatFields = UnifiedFieldSelection<StreamEventResourceSchema>[];
export type InferGetViewerChatResult<
  Fields extends GetViewerChatFields,
> = Array<InferResult<StreamEventResourceSchema, Fields>>;

export type GetViewerChatResult<Fields extends GetViewerChatFields> = | { success: true; data: InferGetViewerChatResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getViewerChat<Fields extends GetViewerChatFields>(
  config: {
  tenant?: string;
  input: GetViewerChatInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetViewerChatResult<Fields>> {
  const payload = {
    action: "get_viewer_chat",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetViewerChatResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read StreamEvent records
 *
 * @ashActionType :read
 */
export async function getViewerChatChannel<Fields extends GetViewerChatFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetViewerChatInput;
  fields: Fields;
  filter?: StreamEventFilterInput;
  sort?: string;
  resultHandler: (result: GetViewerChatResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetViewerChatResult<Fields>>(
    config.channel,
    {
    action: "get_viewer_chat",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type ReplayAlertFields = UnifiedFieldSelection<StreamEventResourceSchema>[];

export type InferReplayAlertResult<
  Fields extends ReplayAlertFields | undefined,
> = InferResult<StreamEventResourceSchema, Fields>;

export type ReplayAlertResult<Fields extends ReplayAlertFields | undefined = undefined> = | { success: true; data: InferReplayAlertResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing StreamEvent
 *
 * @ashActionType :update
 */
export async function replayAlert<Fields extends ReplayAlertFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ReplayAlertResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "replay_alert",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ReplayAlertResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing StreamEvent
 *
 * @ashActionType :update
 */
export async function replayAlertChannel<Fields extends ReplayAlertFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: ReplayAlertResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ReplayAlertResult<Fields>>(
    config.channel,
    {
    action: "replay_alert",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ListViewersInput = {
  userId: UUID;
};

export type ListViewersFields = UnifiedFieldSelection<StreamViewerResourceSchema>[];


export type InferListViewersResult<
  Fields extends ListViewersFields | undefined,
  Page extends ListViewersConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<StreamViewerResourceSchema, Fields>>, {
  results: Array<InferResult<StreamViewerResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListViewersConfig = {
  tenant?: string;
  input: ListViewersInput;
  hookCtx?: ActionHookContext;
  fields: ListViewersFields;
  filter?: StreamViewerFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListViewersResult<Fields extends ListViewersFields, Page extends ListViewersConfig["page"] = undefined> = | { success: true; data: InferListViewersResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamViewer records
 *
 * @ashActionType :read
 */
export async function listViewers<Fields extends ListViewersFields, Config extends ListViewersConfig = ListViewersConfig>(
  config: Config & { fields: Fields }
): Promise<ListViewersResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_viewers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListViewersResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Read StreamViewer records
 *
 * @ashActionType :read
 */
export async function listViewersChannel<Fields extends ListViewersFields>(config: {
  channel: Channel;
  tenant?: string;
  input: ListViewersInput;
  fields: Fields;
  filter?: StreamViewerFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  resultHandler: (result: ListViewersResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ListViewersResult<Fields>>(
    config.channel,
    {
    action: "list_viewers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  },
    config.timeout,
    config
  );
}


export type SearchViewersInput = {
  userId: UUID;
  displayName: string;
  similarityThreshold?: number;
};

export type SearchViewersFields = UnifiedFieldSelection<StreamViewerResourceSchema>[];
export type InferSearchViewersResult<
  Fields extends SearchViewersFields,
> = Array<InferResult<StreamViewerResourceSchema, Fields>>;

export type SearchViewersResult<Fields extends SearchViewersFields> = | { success: true; data: InferSearchViewersResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamViewer records
 *
 * @ashActionType :read
 */
export async function searchViewers<Fields extends SearchViewersFields>(
  config: {
  tenant?: string;
  input: SearchViewersInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: StreamViewerFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SearchViewersResult<Fields>> {
  const payload = {
    action: "search_viewers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<SearchViewersResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read StreamViewer records
 *
 * @ashActionType :read
 */
export async function searchViewersChannel<Fields extends SearchViewersFields>(config: {
  channel: Channel;
  tenant?: string;
  input: SearchViewersInput;
  fields: Fields;
  filter?: StreamViewerFilterInput;
  sort?: string;
  resultHandler: (result: SearchViewersResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SearchViewersResult<Fields>>(
    config.channel,
    {
    action: "search_viewers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type ListBannedViewersInput = {
  userId: UUID;
};

export type ListBannedViewersFields = UnifiedFieldSelection<BannedViewerResourceSchema>[];
export type InferListBannedViewersResult<
  Fields extends ListBannedViewersFields,
> = Array<InferResult<BannedViewerResourceSchema, Fields>>;

export type ListBannedViewersResult<Fields extends ListBannedViewersFields> = | { success: true; data: InferListBannedViewersResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read BannedViewer records
 *
 * @ashActionType :read
 */
export async function listBannedViewers<Fields extends ListBannedViewersFields>(
  config: {
  tenant?: string;
  input: ListBannedViewersInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: BannedViewerFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListBannedViewersResult<Fields>> {
  const payload = {
    action: "list_banned_viewers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ListBannedViewersResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read BannedViewer records
 *
 * @ashActionType :read
 */
export async function listBannedViewersChannel<Fields extends ListBannedViewersFields>(config: {
  channel: Channel;
  tenant?: string;
  input: ListBannedViewersInput;
  fields: Fields;
  filter?: BannedViewerFilterInput;
  sort?: string;
  resultHandler: (result: ListBannedViewersResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ListBannedViewersResult<Fields>>(
    config.channel,
    {
    action: "list_banned_viewers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type GetCurrentStreamDataInput = {
  userId: UUID;
};

export type GetCurrentStreamDataFields = UnifiedFieldSelection<CurrentStreamDataResourceSchema>[];
export type InferGetCurrentStreamDataResult<
  Fields extends GetCurrentStreamDataFields,
> = InferResult<CurrentStreamDataResourceSchema, Fields>;

export type GetCurrentStreamDataResult<Fields extends GetCurrentStreamDataFields> = | { success: true; data: InferGetCurrentStreamDataResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read CurrentStreamData records
 *
 * @ashActionType :read
 */
export async function getCurrentStreamData<Fields extends GetCurrentStreamDataFields>(
  config: {
  tenant?: string;
  input: GetCurrentStreamDataInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetCurrentStreamDataResult<Fields>> {
  const payload = {
    action: "get_current_stream_data",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetCurrentStreamDataResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read CurrentStreamData records
 *
 * @ashActionType :read
 */
export async function getCurrentStreamDataChannel<Fields extends GetCurrentStreamDataFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetCurrentStreamDataInput;
  fields: Fields;
  resultHandler: (result: GetCurrentStreamDataResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetCurrentStreamDataResult<Fields>>(
    config.channel,
    {
    action: "get_current_stream_data",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type HighlightStreamMessageInput = {
  highlightedMessage: Record<string, any>;
};

export type HighlightStreamMessageFields = UnifiedFieldSelection<CurrentStreamDataResourceSchema>[];

export type InferHighlightStreamMessageResult<
  Fields extends HighlightStreamMessageFields | undefined,
> = InferResult<CurrentStreamDataResourceSchema, Fields>;

export type HighlightStreamMessageResult<Fields extends HighlightStreamMessageFields | undefined = undefined> = | { success: true; data: InferHighlightStreamMessageResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing CurrentStreamData
 *
 * @ashActionType :update
 */
export async function highlightStreamMessage<Fields extends HighlightStreamMessageFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: HighlightStreamMessageInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<HighlightStreamMessageResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "highlight_stream_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<HighlightStreamMessageResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing CurrentStreamData
 *
 * @ashActionType :update
 */
export async function highlightStreamMessageChannel<Fields extends HighlightStreamMessageFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: HighlightStreamMessageInput;
  fields?: Fields;
  resultHandler: (result: HighlightStreamMessageResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<HighlightStreamMessageResult<Fields>>(
    config.channel,
    {
    action: "highlight_stream_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ClearStreamHighlightFields = UnifiedFieldSelection<CurrentStreamDataResourceSchema>[];

export type InferClearStreamHighlightResult<
  Fields extends ClearStreamHighlightFields | undefined,
> = InferResult<CurrentStreamDataResourceSchema, Fields>;

export type ClearStreamHighlightResult<Fields extends ClearStreamHighlightFields | undefined = undefined> = | { success: true; data: InferClearStreamHighlightResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing CurrentStreamData
 *
 * @ashActionType :update
 */
export async function clearStreamHighlight<Fields extends ClearStreamHighlightFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ClearStreamHighlightResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "clear_stream_highlight",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ClearStreamHighlightResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing CurrentStreamData
 *
 * @ashActionType :update
 */
export async function clearStreamHighlightChannel<Fields extends ClearStreamHighlightFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: ClearStreamHighlightResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ClearStreamHighlightResult<Fields>>(
    config.channel,
    {
    action: "clear_stream_highlight",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetStreamTimersInput = {
  userId: UUID;
};

export type GetStreamTimersFields = UnifiedFieldSelection<StreamTimerResourceSchema>[];
export type InferGetStreamTimersResult<
  Fields extends GetStreamTimersFields,
> = Array<InferResult<StreamTimerResourceSchema, Fields>>;

export type GetStreamTimersResult<Fields extends GetStreamTimersFields> = | { success: true; data: InferGetStreamTimersResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamTimer records
 *
 * @ashActionType :read
 */
export async function getStreamTimers<Fields extends GetStreamTimersFields>(
  config: {
  tenant?: string;
  input: GetStreamTimersInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: StreamTimerFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetStreamTimersResult<Fields>> {
  const payload = {
    action: "get_stream_timers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetStreamTimersResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read StreamTimer records
 *
 * @ashActionType :read
 */
export async function getStreamTimersChannel<Fields extends GetStreamTimersFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetStreamTimersInput;
  fields: Fields;
  filter?: StreamTimerFilterInput;
  sort?: string;
  resultHandler: (result: GetStreamTimersResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetStreamTimersResult<Fields>>(
    config.channel,
    {
    action: "get_stream_timers",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type CreateStreamTimerInput = {
  label: string;
  content: string;
  intervalSeconds: number;
};

export type CreateStreamTimerFields = UnifiedFieldSelection<StreamTimerResourceSchema>[];

export type InferCreateStreamTimerResult<
  Fields extends CreateStreamTimerFields | undefined,
> = InferResult<StreamTimerResourceSchema, Fields>;

export type CreateStreamTimerResult<Fields extends CreateStreamTimerFields | undefined = undefined> = | { success: true; data: InferCreateStreamTimerResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new StreamTimer
 *
 * @ashActionType :create
 */
export async function createStreamTimer<Fields extends CreateStreamTimerFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateStreamTimerInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateStreamTimerResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateStreamTimerResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new StreamTimer
 *
 * @ashActionType :create
 */
export async function createStreamTimerChannel<Fields extends CreateStreamTimerFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: CreateStreamTimerInput;
  fields?: Fields;
  resultHandler: (result: CreateStreamTimerResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<CreateStreamTimerResult<Fields>>(
    config.channel,
    {
    action: "create_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type UpdateStreamTimerInput = {
  label?: string;
  content?: string;
  intervalSeconds?: number;
};

export type UpdateStreamTimerFields = UnifiedFieldSelection<StreamTimerResourceSchema>[];

export type InferUpdateStreamTimerResult<
  Fields extends UpdateStreamTimerFields | undefined,
> = InferResult<StreamTimerResourceSchema, Fields>;

export type UpdateStreamTimerResult<Fields extends UpdateStreamTimerFields | undefined = undefined> = | { success: true; data: InferUpdateStreamTimerResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing StreamTimer
 *
 * @ashActionType :update
 */
export async function updateStreamTimer<Fields extends UpdateStreamTimerFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateStreamTimerInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateStreamTimerResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateStreamTimerResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing StreamTimer
 *
 * @ashActionType :update
 */
export async function updateStreamTimerChannel<Fields extends UpdateStreamTimerFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: UpdateStreamTimerInput;
  fields?: Fields;
  resultHandler: (result: UpdateStreamTimerResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<UpdateStreamTimerResult<Fields>>(
    config.channel,
    {
    action: "update_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type EnableStreamTimerInput = {
  id: UUID;
};

export type EnableStreamTimerFields = UnifiedFieldSelection<StreamTimerResourceSchema>[];

export type InferEnableStreamTimerResult<
  Fields extends EnableStreamTimerFields | undefined,
> = InferResult<StreamTimerResourceSchema, Fields>;

export type EnableStreamTimerResult<Fields extends EnableStreamTimerFields | undefined = undefined> = | { success: true; data: InferEnableStreamTimerResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing StreamTimer
 *
 * @ashActionType :update
 */
export async function enableStreamTimer<Fields extends EnableStreamTimerFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: EnableStreamTimerInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<EnableStreamTimerResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "enable_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<EnableStreamTimerResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing StreamTimer
 *
 * @ashActionType :update
 */
export async function enableStreamTimerChannel<Fields extends EnableStreamTimerFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: EnableStreamTimerInput;
  fields?: Fields;
  resultHandler: (result: EnableStreamTimerResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<EnableStreamTimerResult<Fields>>(
    config.channel,
    {
    action: "enable_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type DisableStreamTimerInput = {
  id: UUID;
};

export type DisableStreamTimerFields = UnifiedFieldSelection<StreamTimerResourceSchema>[];

export type InferDisableStreamTimerResult<
  Fields extends DisableStreamTimerFields | undefined,
> = InferResult<StreamTimerResourceSchema, Fields>;

export type DisableStreamTimerResult<Fields extends DisableStreamTimerFields | undefined = undefined> = | { success: true; data: InferDisableStreamTimerResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing StreamTimer
 *
 * @ashActionType :update
 */
export async function disableStreamTimer<Fields extends DisableStreamTimerFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: DisableStreamTimerInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DisableStreamTimerResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "disable_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<DisableStreamTimerResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing StreamTimer
 *
 * @ashActionType :update
 */
export async function disableStreamTimerChannel<Fields extends DisableStreamTimerFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: DisableStreamTimerInput;
  fields?: Fields;
  resultHandler: (result: DisableStreamTimerResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<DisableStreamTimerResult<Fields>>(
    config.channel,
    {
    action: "disable_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}



export type DeleteStreamTimerResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a StreamTimer
 *
 * @ashActionType :destroy
 */
export async function deleteStreamTimer(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DeleteStreamTimerResult> {
  const payload = {
    action: "delete_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DeleteStreamTimerResult>(
    payload,
    config
  );
}


/**
 * Delete a StreamTimer
 *
 * @ashActionType :destroy
 */
export async function deleteStreamTimerChannel(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  resultHandler: (result: DeleteStreamTimerResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<DeleteStreamTimerResult>(
    config.channel,
    {
    action: "delete_stream_timer",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  },
    config.timeout,
    config
  );
}


export type HighlightMessageInput = {
  chatMessageId: string;
  message: string;
  senderUsername: string;
  senderChannelId: string;
  platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble";
  viewerId?: string | null;
  userId: UUID;
};

export type HighlightMessageFields = UnifiedFieldSelection<HighlightedMessageResourceSchema>[];

export type InferHighlightMessageResult<
  Fields extends HighlightMessageFields | undefined,
> = InferResult<HighlightedMessageResourceSchema, Fields>;

export type HighlightMessageResult<Fields extends HighlightMessageFields | undefined = undefined> = | { success: true; data: InferHighlightMessageResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new HighlightedMessage
 *
 * @ashActionType :create
 */
export async function highlightMessage<Fields extends HighlightMessageFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: HighlightMessageInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<HighlightMessageResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "highlight_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<HighlightMessageResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new HighlightedMessage
 *
 * @ashActionType :create
 */
export async function highlightMessageChannel<Fields extends HighlightMessageFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: HighlightMessageInput;
  fields?: Fields;
  resultHandler: (result: HighlightMessageResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<HighlightMessageResult<Fields>>(
    config.channel,
    {
    action: "highlight_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ClearHighlightInput = {
  userId: UUID;
};

export type InferClearHighlightResult = boolean;

export type ClearHighlightResult = | { success: true; data: InferClearHighlightResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on HighlightedMessage
 *
 * @ashActionType :action
 */
export async function clearHighlight(
  config: {
  tenant?: string;
  input: ClearHighlightInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ClearHighlightResult> {
  const payload = {
    action: "clear_highlight",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<ClearHighlightResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on HighlightedMessage
 *
 * @ashActionType :action
 */
export async function clearHighlightChannel(config: {
  channel: Channel;
  tenant?: string;
  input: ClearHighlightInput;
  resultHandler: (result: ClearHighlightResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ClearHighlightResult>(
    config.channel,
    {
    action: "clear_highlight",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type GetHighlightedMessageInput = {
  userId: UUID;
};

export type GetHighlightedMessageFields = UnifiedFieldSelection<HighlightedMessageResourceSchema>[];
export type InferGetHighlightedMessageResult<
  Fields extends GetHighlightedMessageFields,
> = Array<InferResult<HighlightedMessageResourceSchema, Fields>>;

export type GetHighlightedMessageResult<Fields extends GetHighlightedMessageFields> = | { success: true; data: InferGetHighlightedMessageResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read HighlightedMessage records
 *
 * @ashActionType :read
 */
export async function getHighlightedMessage<Fields extends GetHighlightedMessageFields>(
  config: {
  tenant?: string;
  input: GetHighlightedMessageInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: HighlightedMessageFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetHighlightedMessageResult<Fields>> {
  const payload = {
    action: "get_highlighted_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetHighlightedMessageResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read HighlightedMessage records
 *
 * @ashActionType :read
 */
export async function getHighlightedMessageChannel<Fields extends GetHighlightedMessageFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetHighlightedMessageInput;
  fields: Fields;
  filter?: HighlightedMessageFilterInput;
  sort?: string;
  resultHandler: (result: GetHighlightedMessageResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetHighlightedMessageResult<Fields>>(
    config.channel,
    {
    action: "get_highlighted_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type GetChatBotConfigInput = {
  userId: UUID;
};

export type GetChatBotConfigFields = UnifiedFieldSelection<ChatBotConfigResourceSchema>[];
export type InferGetChatBotConfigResult<
  Fields extends GetChatBotConfigFields,
> = Array<InferResult<ChatBotConfigResourceSchema, Fields>>;

export type GetChatBotConfigResult<Fields extends GetChatBotConfigFields> = | { success: true; data: InferGetChatBotConfigResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read ChatBotConfig records
 *
 * @ashActionType :read
 */
export async function getChatBotConfig<Fields extends GetChatBotConfigFields>(
  config: {
  tenant?: string;
  input: GetChatBotConfigInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: ChatBotConfigFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetChatBotConfigResult<Fields>> {
  const payload = {
    action: "get_chat_bot_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetChatBotConfigResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read ChatBotConfig records
 *
 * @ashActionType :read
 */
export async function getChatBotConfigChannel<Fields extends GetChatBotConfigFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetChatBotConfigInput;
  fields: Fields;
  filter?: ChatBotConfigFilterInput;
  sort?: string;
  resultHandler: (result: GetChatBotConfigResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetChatBotConfigResult<Fields>>(
    config.channel,
    {
    action: "get_chat_bot_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type UpsertChatBotConfigInput = {
  enabled?: boolean;
  greetingEnabled?: boolean;
  greetingMessage?: string;
  commandPrefix?: string;
  aiChatEnabled?: boolean;
  aiPersonality?: string | null;
  aiBotName?: string;
  aiProvider?: string;
  autoShoutoutEnabled?: boolean;
  linkProtectionEnabled?: boolean;
  slowModeOnRaidEnabled?: boolean;
};

export type UpsertChatBotConfigFields = UnifiedFieldSelection<ChatBotConfigResourceSchema>[];

export type InferUpsertChatBotConfigResult<
  Fields extends UpsertChatBotConfigFields | undefined,
> = InferResult<ChatBotConfigResourceSchema, Fields>;

export type UpsertChatBotConfigResult<Fields extends UpsertChatBotConfigFields | undefined = undefined> = | { success: true; data: InferUpsertChatBotConfigResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new ChatBotConfig
 *
 * @ashActionType :create
 */
export async function upsertChatBotConfig<Fields extends UpsertChatBotConfigFields | undefined = undefined>(
  config: {
  tenant?: string;
  input?: UpsertChatBotConfigInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpsertChatBotConfigResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "upsert_chat_bot_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpsertChatBotConfigResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new ChatBotConfig
 *
 * @ashActionType :create
 */
export async function upsertChatBotConfigChannel<Fields extends UpsertChatBotConfigFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input?: UpsertChatBotConfigInput;
  fields?: Fields;
  resultHandler: (result: UpsertChatBotConfigResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<UpsertChatBotConfigResult<Fields>>(
    config.channel,
    {
    action: "upsert_chat_bot_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type UpdateChatBotConfigInput = {
  enabled?: boolean;
  greetingEnabled?: boolean;
  greetingMessage?: string;
  commandPrefix?: string;
  aiChatEnabled?: boolean;
  aiPersonality?: string | null;
  aiBotName?: string;
  aiProvider?: string;
  autoShoutoutEnabled?: boolean;
  linkProtectionEnabled?: boolean;
  slowModeOnRaidEnabled?: boolean;
};

export type UpdateChatBotConfigFields = UnifiedFieldSelection<ChatBotConfigResourceSchema>[];

export type InferUpdateChatBotConfigResult<
  Fields extends UpdateChatBotConfigFields | undefined,
> = InferResult<ChatBotConfigResourceSchema, Fields>;

export type UpdateChatBotConfigResult<Fields extends UpdateChatBotConfigFields | undefined = undefined> = | { success: true; data: InferUpdateChatBotConfigResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing ChatBotConfig
 *
 * @ashActionType :update
 */
export async function updateChatBotConfig<Fields extends UpdateChatBotConfigFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: UpdateChatBotConfigInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateChatBotConfigResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_chat_bot_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateChatBotConfigResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing ChatBotConfig
 *
 * @ashActionType :update
 */
export async function updateChatBotConfigChannel<Fields extends UpdateChatBotConfigFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input?: UpdateChatBotConfigInput;
  fields?: Fields;
  resultHandler: (result: UpdateChatBotConfigResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<UpdateChatBotConfigResult<Fields>>(
    config.channel,
    {
    action: "update_chat_bot_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GoLiveInput = {
  userId: UUID;
  title?: string;
  description?: string;
  platforms?: Array<string>;
  metadata?: Record<string, any>;
};

export type InferGoLiveResult = Record<string, any>;

export type GoLiveResult = | { success: true; data: InferGoLiveResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function goLive(
  config: {
  tenant?: string;
  input: GoLiveInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GoLiveResult> {
  const payload = {
    action: "go_live",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<GoLiveResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function goLiveChannel(config: {
  channel: Channel;
  tenant?: string;
  input: GoLiveInput;
  resultHandler: (result: GoLiveResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GoLiveResult>(
    config.channel,
    {
    action: "go_live",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type StopStreamInput = {
  userId: UUID;
};

export type InferStopStreamResult = Record<string, any>;

export type StopStreamResult = | { success: true; data: InferStopStreamResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function stopStream(
  config: {
  tenant?: string;
  input: StopStreamInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<StopStreamResult> {
  const payload = {
    action: "stop_stream",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<StopStreamResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function stopStreamChannel(config: {
  channel: Channel;
  tenant?: string;
  input: StopStreamInput;
  resultHandler: (result: StopStreamResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<StopStreamResult>(
    config.channel,
    {
    action: "stop_stream",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type UpdateStreamMetadataInput = {
  userId: UUID;
  title?: string;
  description?: string;
  tags?: Array<string>;
  thumbnailFileId?: UUID;
  platforms?: Array<string>;
};

export type InferUpdateStreamMetadataResult = Record<string, any>;

export type UpdateStreamMetadataResult = | { success: true; data: InferUpdateStreamMetadataResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function updateStreamMetadata(
  config: {
  tenant?: string;
  input: UpdateStreamMetadataInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateStreamMetadataResult> {
  const payload = {
    action: "update_stream_metadata",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<UpdateStreamMetadataResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function updateStreamMetadataChannel(config: {
  channel: Channel;
  tenant?: string;
  input: UpdateStreamMetadataInput;
  resultHandler: (result: UpdateStreamMetadataResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<UpdateStreamMetadataResult>(
    config.channel,
    {
    action: "update_stream_metadata",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type SendStreamMessageInput = {
  userId: UUID;
  message: string;
  platforms?: Array<string>;
};

export type InferSendStreamMessageResult = Record<string, any>;

export type SendStreamMessageResult = | { success: true; data: InferSendStreamMessageResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function sendStreamMessage(
  config: {
  tenant?: string;
  input: SendStreamMessageInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SendStreamMessageResult> {
  const payload = {
    action: "send_stream_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<SendStreamMessageResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function sendStreamMessageChannel(config: {
  channel: Channel;
  tenant?: string;
  input: SendStreamMessageInput;
  resultHandler: (result: SendStreamMessageResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SendStreamMessageResult>(
    config.channel,
    {
    action: "send_stream_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type TogglePlatformInput = {
  userId: UUID;
  platform: string;
  enabled: boolean;
};

export type InferTogglePlatformResult = Record<string, any>;

export type TogglePlatformResult = | { success: true; data: InferTogglePlatformResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function togglePlatform(
  config: {
  tenant?: string;
  input: TogglePlatformInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TogglePlatformResult> {
  const payload = {
    action: "toggle_platform",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<TogglePlatformResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on StreamAction
 *
 * @ashActionType :action
 */
export async function togglePlatformChannel(config: {
  channel: Channel;
  tenant?: string;
  input: TogglePlatformInput;
  resultHandler: (result: TogglePlatformResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<TogglePlatformResult>(
    config.channel,
    {
    action: "toggle_platform",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type GetCurrentUserFields = UnifiedFieldSelection<UserResourceSchema>[];
export type InferGetCurrentUserResult<
  Fields extends GetCurrentUserFields,
> = InferResult<UserResourceSchema, Fields>;

export type GetCurrentUserResult<Fields extends GetCurrentUserFields> = | { success: true; data: InferGetCurrentUserResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getCurrentUser<Fields extends GetCurrentUserFields>(
  config: {
  tenant?: string;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetCurrentUserResult<Fields>> {
  const payload = {
    action: "get_current_user",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetCurrentUserResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getCurrentUserChannel<Fields extends GetCurrentUserFields>(config: {
  channel: Channel;
  tenant?: string;
  fields: Fields;
  resultHandler: (result: GetCurrentUserResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetCurrentUserResult<Fields>>(
    config.channel,
    {
    action: "get_current_user",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetPublicProfileInput = {
  username: string;
};

export type GetPublicProfileFields = UnifiedFieldSelection<UserResourceSchema>[];
export type InferGetPublicProfileResult<
  Fields extends GetPublicProfileFields,
> = InferResult<UserResourceSchema, Fields>;

export type GetPublicProfileResult<Fields extends GetPublicProfileFields> = | { success: true; data: InferGetPublicProfileResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getPublicProfile<Fields extends GetPublicProfileFields>(
  config: {
  tenant?: string;
  input: GetPublicProfileInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetPublicProfileResult<Fields>> {
  const payload = {
    action: "get_public_profile",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetPublicProfileResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getPublicProfileChannel<Fields extends GetPublicProfileFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetPublicProfileInput;
  fields: Fields;
  resultHandler: (result: GetPublicProfileResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetPublicProfileResult<Fields>>(
    config.channel,
    {
    action: "get_public_profile",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ListUsersFields = UnifiedFieldSelection<UserResourceSchema>[];


export type InferListUsersResult<
  Fields extends ListUsersFields | undefined,
  Page extends ListUsersConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<UserResourceSchema, Fields>>, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListUsersConfig = {
  tenant?: string;
  hookCtx?: ActionHookContext;
  fields: ListUsersFields;
  filter?: UserFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListUsersResult<Fields extends ListUsersFields, Page extends ListUsersConfig["page"] = undefined> = | { success: true; data: InferListUsersResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function listUsers<Fields extends ListUsersFields, Config extends ListUsersConfig = ListUsersConfig>(
  config: Config & { fields: Fields }
): Promise<ListUsersResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_users",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListUsersResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function listUsersChannel<Fields extends ListUsersFields>(config: {
  channel: Channel;
  tenant?: string;
  fields: Fields;
  filter?: UserFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  resultHandler: (result: ListUsersResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ListUsersResult<Fields>>(
    config.channel,
    {
    action: "list_users",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  },
    config.timeout,
    config
  );
}


export type GetUserByNameInput = {
  name: string;
};

export type GetUserByNameFields = UnifiedFieldSelection<UserResourceSchema>[];
export type InferGetUserByNameResult<
  Fields extends GetUserByNameFields,
> = InferResult<UserResourceSchema, Fields>;

export type GetUserByNameResult<Fields extends GetUserByNameFields> = | { success: true; data: InferGetUserByNameResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getUserByName<Fields extends GetUserByNameFields>(
  config: {
  tenant?: string;
  input: GetUserByNameInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetUserByNameResult<Fields>> {
  const payload = {
    action: "get_user_by_name",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetUserByNameResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getUserByNameChannel<Fields extends GetUserByNameFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetUserByNameInput;
  fields: Fields;
  resultHandler: (result: GetUserByNameResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetUserByNameResult<Fields>>(
    config.channel,
    {
    action: "get_user_by_name",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetUserInfoInput = {
  id: string;
};

export type GetUserInfoFields = UnifiedFieldSelection<UserResourceSchema>[];
export type InferGetUserInfoResult<
  Fields extends GetUserInfoFields,
> = InferResult<UserResourceSchema, Fields>;

export type GetUserInfoResult<Fields extends GetUserInfoFields> = | { success: true; data: InferGetUserInfoResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getUserInfo<Fields extends GetUserInfoFields>(
  config: {
  tenant?: string;
  input: GetUserInfoInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetUserInfoResult<Fields>> {
  const payload = {
    action: "get_user_info",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetUserInfoResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function getUserInfoChannel<Fields extends GetUserInfoFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetUserInfoInput;
  fields: Fields;
  resultHandler: (result: GetUserInfoResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetUserInfoResult<Fields>>(
    config.channel,
    {
    action: "get_user_info",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type UpdateNameInput = {
  name?: string;
};

export type UpdateNameFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferUpdateNameResult<
  Fields extends UpdateNameFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type UpdateNameResult<Fields extends UpdateNameFields | undefined = undefined> = | { success: true; data: InferUpdateNameResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateName<Fields extends UpdateNameFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateNameInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateNameResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_name",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateNameResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateNameChannel<Fields extends UpdateNameFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: UpdateNameInput;
  fields?: Fields;
  resultHandler: (result: UpdateNameResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<UpdateNameResult<Fields>>(
    config.channel,
    {
    action: "update_name",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type UpdateAvatarInput = {
  avatarFileId?: UUID | null;
  fileId: UUID;
};

export type UpdateAvatarFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferUpdateAvatarResult<
  Fields extends UpdateAvatarFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type UpdateAvatarResult<Fields extends UpdateAvatarFields | undefined = undefined> = | { success: true; data: InferUpdateAvatarResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateAvatar<Fields extends UpdateAvatarFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateAvatarInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateAvatarResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_avatar",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateAvatarResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateAvatarChannel<Fields extends UpdateAvatarFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: UpdateAvatarInput;
  fields?: Fields;
  resultHandler: (result: UpdateAvatarResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<UpdateAvatarResult<Fields>>(
    config.channel,
    {
    action: "update_avatar",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ToggleEmailNotificationsFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferToggleEmailNotificationsResult<
  Fields extends ToggleEmailNotificationsFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type ToggleEmailNotificationsResult<Fields extends ToggleEmailNotificationsFields | undefined = undefined> = | { success: true; data: InferToggleEmailNotificationsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function toggleEmailNotifications<Fields extends ToggleEmailNotificationsFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ToggleEmailNotificationsResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "toggle_email_notifications",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ToggleEmailNotificationsResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function toggleEmailNotificationsChannel<Fields extends ToggleEmailNotificationsFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: ToggleEmailNotificationsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ToggleEmailNotificationsResult<Fields>>(
    config.channel,
    {
    action: "toggle_email_notifications",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type SaveDonationSettingsInput = {
  minAmount?: number;
  maxAmount?: number;
  currency?: string;
  defaultVoice?: string;
};

export type SaveDonationSettingsFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferSaveDonationSettingsResult<
  Fields extends SaveDonationSettingsFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type SaveDonationSettingsResult<Fields extends SaveDonationSettingsFields | undefined = undefined> = | { success: true; data: InferSaveDonationSettingsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function saveDonationSettings<Fields extends SaveDonationSettingsFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: SaveDonationSettingsInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SaveDonationSettingsResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "save_donation_settings",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<SaveDonationSettingsResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function saveDonationSettingsChannel<Fields extends SaveDonationSettingsFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input?: SaveDonationSettingsInput;
  fields?: Fields;
  resultHandler: (result: SaveDonationSettingsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SaveDonationSettingsResult<Fields>>(
    config.channel,
    {
    action: "save_donation_settings",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type SaveLanguagePreferenceInput = {
  language: string;
};

export type SaveLanguagePreferenceFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferSaveLanguagePreferenceResult<
  Fields extends SaveLanguagePreferenceFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type SaveLanguagePreferenceResult<Fields extends SaveLanguagePreferenceFields | undefined = undefined> = | { success: true; data: InferSaveLanguagePreferenceResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function saveLanguagePreference<Fields extends SaveLanguagePreferenceFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: SaveLanguagePreferenceInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SaveLanguagePreferenceResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "save_language_preference",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<SaveLanguagePreferenceResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function saveLanguagePreferenceChannel<Fields extends SaveLanguagePreferenceFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: SaveLanguagePreferenceInput;
  fields?: Fields;
  resultHandler: (result: SaveLanguagePreferenceResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SaveLanguagePreferenceResult<Fields>>(
    config.channel,
    {
    action: "save_language_preference",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GrantProAccessInput = {
  durationDays: number;
  reason: string;
};

export type GrantProAccessFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferGrantProAccessResult<
  Fields extends GrantProAccessFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type GrantProAccessResult<Fields extends GrantProAccessFields | undefined = undefined> = | { success: true; data: InferGrantProAccessResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function grantProAccess<Fields extends GrantProAccessFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: GrantProAccessInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GrantProAccessResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "grant_pro_access",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GrantProAccessResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function grantProAccessChannel<Fields extends GrantProAccessFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input: GrantProAccessInput;
  fields?: Fields;
  resultHandler: (result: GrantProAccessResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GrantProAccessResult<Fields>>(
    config.channel,
    {
    action: "grant_pro_access",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type RevokeProAccessFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferRevokeProAccessResult<
  Fields extends RevokeProAccessFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type RevokeProAccessResult<Fields extends RevokeProAccessFields | undefined = undefined> = | { success: true; data: InferRevokeProAccessResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function revokeProAccess<Fields extends RevokeProAccessFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RevokeProAccessResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "revoke_pro_access",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<RevokeProAccessResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function revokeProAccessChannel<Fields extends RevokeProAccessFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: RevokeProAccessResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<RevokeProAccessResult<Fields>>(
    config.channel,
    {
    action: "revoke_pro_access",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type InviteUserRoleInput = {
  userId: UUID;
  granterId: UUID;
  roleType: string;
};

export type InviteUserRoleFields = UnifiedFieldSelection<UserRoleResourceSchema>[];

export type InferInviteUserRoleResult<
  Fields extends InviteUserRoleFields | undefined,
> = InferResult<UserRoleResourceSchema, Fields>;

export type InviteUserRoleResult<Fields extends InviteUserRoleFields | undefined = undefined> = | { success: true; data: InferInviteUserRoleResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new UserRole
 *
 * @ashActionType :create
 */
export async function inviteUserRole<Fields extends InviteUserRoleFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: InviteUserRoleInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InviteUserRoleResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "invite_user_role",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InviteUserRoleResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new UserRole
 *
 * @ashActionType :create
 */
export async function inviteUserRoleChannel<Fields extends InviteUserRoleFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: InviteUserRoleInput;
  fields?: Fields;
  resultHandler: (result: InviteUserRoleResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<InviteUserRoleResult<Fields>>(
    config.channel,
    {
    action: "invite_user_role",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type AcceptRoleInvitationFields = UnifiedFieldSelection<UserRoleResourceSchema>[];

export type InferAcceptRoleInvitationResult<
  Fields extends AcceptRoleInvitationFields | undefined,
> = InferResult<UserRoleResourceSchema, Fields>;

export type AcceptRoleInvitationResult<Fields extends AcceptRoleInvitationFields | undefined = undefined> = | { success: true; data: InferAcceptRoleInvitationResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing UserRole
 *
 * @ashActionType :update
 */
export async function acceptRoleInvitation<Fields extends AcceptRoleInvitationFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<AcceptRoleInvitationResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "accept_role_invitation",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<AcceptRoleInvitationResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing UserRole
 *
 * @ashActionType :update
 */
export async function acceptRoleInvitationChannel<Fields extends AcceptRoleInvitationFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: AcceptRoleInvitationResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<AcceptRoleInvitationResult<Fields>>(
    config.channel,
    {
    action: "accept_role_invitation",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type DeclineRoleInvitationFields = UnifiedFieldSelection<UserRoleResourceSchema>[];

export type InferDeclineRoleInvitationResult<
  Fields extends DeclineRoleInvitationFields | undefined,
> = InferResult<UserRoleResourceSchema, Fields>;

export type DeclineRoleInvitationResult<Fields extends DeclineRoleInvitationFields | undefined = undefined> = | { success: true; data: InferDeclineRoleInvitationResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing UserRole
 *
 * @ashActionType :update
 */
export async function declineRoleInvitation<Fields extends DeclineRoleInvitationFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DeclineRoleInvitationResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "decline_role_invitation",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<DeclineRoleInvitationResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing UserRole
 *
 * @ashActionType :update
 */
export async function declineRoleInvitationChannel<Fields extends DeclineRoleInvitationFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: DeclineRoleInvitationResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<DeclineRoleInvitationResult<Fields>>(
    config.channel,
    {
    action: "decline_role_invitation",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type RevokeUserRoleFields = UnifiedFieldSelection<UserRoleResourceSchema>[];

export type InferRevokeUserRoleResult<
  Fields extends RevokeUserRoleFields | undefined,
> = InferResult<UserRoleResourceSchema, Fields>;

export type RevokeUserRoleResult<Fields extends RevokeUserRoleFields | undefined = undefined> = | { success: true; data: InferRevokeUserRoleResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing UserRole
 *
 * @ashActionType :update
 */
export async function revokeUserRole<Fields extends RevokeUserRoleFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RevokeUserRoleResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "revoke_user_role",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<RevokeUserRoleResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing UserRole
 *
 * @ashActionType :update
 */
export async function revokeUserRoleChannel<Fields extends RevokeUserRoleFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: RevokeUserRoleResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<RevokeUserRoleResult<Fields>>(
    config.channel,
    {
    action: "revoke_user_role",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetWidgetConfigInput = {
  userId: UUID;
  type: string;
};

export type GetWidgetConfigFields = UnifiedFieldSelection<WidgetConfigResourceSchema>[];
export type InferGetWidgetConfigResult<
  Fields extends GetWidgetConfigFields,
> = InferResult<WidgetConfigResourceSchema, Fields>;

export type GetWidgetConfigResult<Fields extends GetWidgetConfigFields> = | { success: true; data: InferGetWidgetConfigResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read WidgetConfig records
 *
 * @ashActionType :read
 */
export async function getWidgetConfig<Fields extends GetWidgetConfigFields>(
  config: {
  tenant?: string;
  input: GetWidgetConfigInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetWidgetConfigResult<Fields>> {
  const payload = {
    action: "get_widget_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetWidgetConfigResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read WidgetConfig records
 *
 * @ashActionType :read
 */
export async function getWidgetConfigChannel<Fields extends GetWidgetConfigFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetWidgetConfigInput;
  fields: Fields;
  resultHandler: (result: GetWidgetConfigResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetWidgetConfigResult<Fields>>(
    config.channel,
    {
    action: "get_widget_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ListWidgetConfigsFields = UnifiedFieldSelection<WidgetConfigResourceSchema>[];


export type InferListWidgetConfigsResult<
  Fields extends ListWidgetConfigsFields | undefined,
  Page extends ListWidgetConfigsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<WidgetConfigResourceSchema, Fields>>, {
  results: Array<InferResult<WidgetConfigResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<WidgetConfigResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListWidgetConfigsConfig = {
  tenant?: string;
  hookCtx?: ActionHookContext;
  fields: ListWidgetConfigsFields;
  filter?: WidgetConfigFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListWidgetConfigsResult<Fields extends ListWidgetConfigsFields, Page extends ListWidgetConfigsConfig["page"] = undefined> = | { success: true; data: InferListWidgetConfigsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read WidgetConfig records
 *
 * @ashActionType :read
 */
export async function listWidgetConfigs<Fields extends ListWidgetConfigsFields, Config extends ListWidgetConfigsConfig = ListWidgetConfigsConfig>(
  config: Config & { fields: Fields }
): Promise<ListWidgetConfigsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_widget_configs",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListWidgetConfigsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Read WidgetConfig records
 *
 * @ashActionType :read
 */
export async function listWidgetConfigsChannel<Fields extends ListWidgetConfigsFields>(config: {
  channel: Channel;
  tenant?: string;
  fields: Fields;
  filter?: WidgetConfigFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  resultHandler: (result: ListWidgetConfigsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ListWidgetConfigsResult<Fields>>(
    config.channel,
    {
    action: "list_widget_configs",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  },
    config.timeout,
    config
  );
}


export type SaveWidgetConfigInput = {
  userId: UUID;
  type: string;
  config?: Record<string, any>;
};

export type SaveWidgetConfigFields = UnifiedFieldSelection<WidgetConfigResourceSchema>[];

export type InferSaveWidgetConfigResult<
  Fields extends SaveWidgetConfigFields | undefined,
> = InferResult<WidgetConfigResourceSchema, Fields>;

export type SaveWidgetConfigResult<Fields extends SaveWidgetConfigFields | undefined = undefined> = | { success: true; data: InferSaveWidgetConfigResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new WidgetConfig
 *
 * @ashActionType :create
 */
export async function saveWidgetConfig<Fields extends SaveWidgetConfigFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: SaveWidgetConfigInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SaveWidgetConfigResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "save_widget_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<SaveWidgetConfigResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new WidgetConfig
 *
 * @ashActionType :create
 */
export async function saveWidgetConfigChannel<Fields extends SaveWidgetConfigFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: SaveWidgetConfigInput;
  fields?: Fields;
  resultHandler: (result: SaveWidgetConfigResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SaveWidgetConfigResult<Fields>>(
    config.channel,
    {
    action: "save_widget_config",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ListStreamingAccountsFields = UnifiedFieldSelection<StreamingAccountResourceSchema>[];


export type InferListStreamingAccountsResult<
  Fields extends ListStreamingAccountsFields | undefined,
  Page extends ListStreamingAccountsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<StreamingAccountResourceSchema, Fields>>, {
  results: Array<InferResult<StreamingAccountResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<StreamingAccountResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListStreamingAccountsConfig = {
  tenant?: string;
  hookCtx?: ActionHookContext;
  fields: ListStreamingAccountsFields;
  filter?: StreamingAccountFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListStreamingAccountsResult<Fields extends ListStreamingAccountsFields, Page extends ListStreamingAccountsConfig["page"] = undefined> = | { success: true; data: InferListStreamingAccountsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read StreamingAccount records
 *
 * @ashActionType :read
 */
export async function listStreamingAccounts<Fields extends ListStreamingAccountsFields, Config extends ListStreamingAccountsConfig = ListStreamingAccountsConfig>(
  config: Config & { fields: Fields }
): Promise<ListStreamingAccountsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_streaming_accounts",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListStreamingAccountsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Read StreamingAccount records
 *
 * @ashActionType :read
 */
export async function listStreamingAccountsChannel<Fields extends ListStreamingAccountsFields>(config: {
  channel: Channel;
  tenant?: string;
  fields: Fields;
  filter?: StreamingAccountFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  resultHandler: (result: ListStreamingAccountsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ListStreamingAccountsResult<Fields>>(
    config.channel,
    {
    action: "list_streaming_accounts",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  },
    config.timeout,
    config
  );
}


export type RefreshStreamingAccountStatsFields = UnifiedFieldSelection<StreamingAccountResourceSchema>[];

export type InferRefreshStreamingAccountStatsResult<
  Fields extends RefreshStreamingAccountStatsFields | undefined,
> = InferResult<StreamingAccountResourceSchema, Fields>;

export type RefreshStreamingAccountStatsResult<Fields extends RefreshStreamingAccountStatsFields | undefined = undefined> = | { success: true; data: InferRefreshStreamingAccountStatsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing StreamingAccount
 *
 * @ashActionType :update
 */
export async function refreshStreamingAccountStats<Fields extends RefreshStreamingAccountStatsFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: { userId: UUID; platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble" };
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RefreshStreamingAccountStatsResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "refresh_streaming_account_stats",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<RefreshStreamingAccountStatsResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing StreamingAccount
 *
 * @ashActionType :update
 */
export async function refreshStreamingAccountStatsChannel<Fields extends RefreshStreamingAccountStatsFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: { userId: UUID; platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble" };
  fields?: Fields;
  resultHandler: (result: RefreshStreamingAccountStatsResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<RefreshStreamingAccountStatsResult<Fields>>(
    config.channel,
    {
    action: "refresh_streaming_account_stats",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}



export type DisconnectStreamingAccountResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a StreamingAccount
 *
 * @ashActionType :destroy
 */
export async function disconnectStreamingAccount(
  config: {
  tenant?: string;
  identity: { userId: UUID; platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble" };
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DisconnectStreamingAccountResult> {
  const payload = {
    action: "disconnect_streaming_account",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DisconnectStreamingAccountResult>(
    payload,
    config
  );
}


/**
 * Delete a StreamingAccount
 *
 * @ashActionType :destroy
 */
export async function disconnectStreamingAccountChannel(config: {
  channel: Channel;
  tenant?: string;
  identity: { userId: UUID; platform: "youtube" | "twitch" | "facebook" | "kick" | "tiktok" | "trovo" | "instagram" | "rumble" };
  resultHandler: (result: DisconnectStreamingAccountResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<DisconnectStreamingAccountResult>(
    config.channel,
    {
    action: "disconnect_streaming_account",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  },
    config.timeout,
    config
  );
}


export type GetSmartCanvasLayoutInput = {
  userId: UUID;
};

export type GetSmartCanvasLayoutFields = UnifiedFieldSelection<SmartCanvasLayoutResourceSchema>[];
export type InferGetSmartCanvasLayoutResult<
  Fields extends GetSmartCanvasLayoutFields,
> = InferResult<SmartCanvasLayoutResourceSchema, Fields>;

export type GetSmartCanvasLayoutResult<Fields extends GetSmartCanvasLayoutFields> = | { success: true; data: InferGetSmartCanvasLayoutResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read SmartCanvasLayout records
 *
 * @ashActionType :read
 */
export async function getSmartCanvasLayout<Fields extends GetSmartCanvasLayoutFields>(
  config: {
  tenant?: string;
  input: GetSmartCanvasLayoutInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetSmartCanvasLayoutResult<Fields>> {
  const payload = {
    action: "get_smart_canvas_layout",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GetSmartCanvasLayoutResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read SmartCanvasLayout records
 *
 * @ashActionType :read
 */
export async function getSmartCanvasLayoutChannel<Fields extends GetSmartCanvasLayoutFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetSmartCanvasLayoutInput;
  fields: Fields;
  resultHandler: (result: GetSmartCanvasLayoutResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetSmartCanvasLayoutResult<Fields>>(
    config.channel,
    {
    action: "get_smart_canvas_layout",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type SaveSmartCanvasLayoutInput = {
  userId: UUID;
  widgets?: Array<Record<string, any>>;
};

export type SaveSmartCanvasLayoutFields = UnifiedFieldSelection<SmartCanvasLayoutResourceSchema>[];

export type InferSaveSmartCanvasLayoutResult<
  Fields extends SaveSmartCanvasLayoutFields | undefined,
> = InferResult<SmartCanvasLayoutResourceSchema, Fields>;

export type SaveSmartCanvasLayoutResult<Fields extends SaveSmartCanvasLayoutFields | undefined = undefined> = | { success: true; data: InferSaveSmartCanvasLayoutResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new SmartCanvasLayout
 *
 * @ashActionType :create
 */
export async function saveSmartCanvasLayout<Fields extends SaveSmartCanvasLayoutFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: SaveSmartCanvasLayoutInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SaveSmartCanvasLayoutResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "save_smart_canvas_layout",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<SaveSmartCanvasLayoutResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new SmartCanvasLayout
 *
 * @ashActionType :create
 */
export async function saveSmartCanvasLayoutChannel<Fields extends SaveSmartCanvasLayoutFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: SaveSmartCanvasLayoutInput;
  fields?: Fields;
  resultHandler: (result: SaveSmartCanvasLayoutResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SaveSmartCanvasLayoutResult<Fields>>(
    config.channel,
    {
    action: "save_smart_canvas_layout",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type GetStreamKeyInput = {
  userId: UUID;
  orientation?: string;
};

export type GetStreamKeyFields = UnifiedFieldSelection<LiveInputResourceSchema>[];
export type InferGetStreamKeyResult<
  Fields extends GetStreamKeyFields,
> = Array<InferResult<LiveInputResourceSchema, Fields>>;

export type GetStreamKeyResult<Fields extends GetStreamKeyFields> = | { success: true; data: InferGetStreamKeyResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read LiveInput records
 *
 * @ashActionType :read
 */
export async function getStreamKey<Fields extends GetStreamKeyFields>(
  config: {
  tenant?: string;
  input: GetStreamKeyInput;
  hookCtx?: ActionHookContext;
  fields: Fields;
  filter?: LiveInputFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetStreamKeyResult<Fields>> {
  const payload = {
    action: "get_stream_key",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetStreamKeyResult<Fields>>(
    payload,
    config
  );
}


/**
 * Read LiveInput records
 *
 * @ashActionType :read
 */
export async function getStreamKeyChannel<Fields extends GetStreamKeyFields>(config: {
  channel: Channel;
  tenant?: string;
  input: GetStreamKeyInput;
  fields: Fields;
  filter?: LiveInputFilterInput;
  sort?: string;
  resultHandler: (result: GetStreamKeyResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<GetStreamKeyResult<Fields>>(
    config.channel,
    {
    action: "get_stream_key",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  },
    config.timeout,
    config
  );
}


export type RegenerateStreamKeyFields = UnifiedFieldSelection<LiveInputResourceSchema>[];

export type InferRegenerateStreamKeyResult<
  Fields extends RegenerateStreamKeyFields | undefined,
> = InferResult<LiveInputResourceSchema, Fields>;

export type RegenerateStreamKeyResult<Fields extends RegenerateStreamKeyFields | undefined = undefined> = | { success: true; data: InferRegenerateStreamKeyResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing LiveInput
 *
 * @ashActionType :update
 */
export async function regenerateStreamKey<Fields extends RegenerateStreamKeyFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: { userId: UUID; orientation: "horizontal" | "vertical" };
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RegenerateStreamKeyResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "regenerate_stream_key",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<RegenerateStreamKeyResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing LiveInput
 *
 * @ashActionType :update
 */
export async function regenerateStreamKeyChannel<Fields extends RegenerateStreamKeyFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: { userId: UUID; orientation: "horizontal" | "vertical" };
  fields?: Fields;
  resultHandler: (result: RegenerateStreamKeyResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<RegenerateStreamKeyResult<Fields>>(
    config.channel,
    {
    action: "regenerate_stream_key",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type CreateNotificationInput = {
  userId?: UUID | null;
  content: string;
  contentDe?: string | null;
  contentPl?: string | null;
  contentEs?: string | null;
};

export type CreateNotificationFields = UnifiedFieldSelection<NotificationResourceSchema>[];

export type InferCreateNotificationResult<
  Fields extends CreateNotificationFields | undefined,
> = InferResult<NotificationResourceSchema, Fields>;

export type CreateNotificationResult<Fields extends CreateNotificationFields | undefined = undefined> = | { success: true; data: InferCreateNotificationResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Notification
 *
 * @ashActionType :create
 */
export async function createNotification<Fields extends CreateNotificationFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateNotificationInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateNotificationResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_notification",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateNotificationResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new Notification
 *
 * @ashActionType :create
 */
export async function createNotificationChannel<Fields extends CreateNotificationFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: CreateNotificationInput;
  fields?: Fields;
  resultHandler: (result: CreateNotificationResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<CreateNotificationResult<Fields>>(
    config.channel,
    {
    action: "create_notification",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}



export type DeleteNotificationResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a Notification
 *
 * @ashActionType :destroy
 */
export async function deleteNotification(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DeleteNotificationResult> {
  const payload = {
    action: "delete_notification",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<DeleteNotificationResult>(
    payload,
    config
  );
}


/**
 * Delete a Notification
 *
 * @ashActionType :destroy
 */
export async function deleteNotificationChannel(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  resultHandler: (result: DeleteNotificationResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<DeleteNotificationResult>(
    config.channel,
    {
    action: "delete_notification",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  },
    config.timeout,
    config
  );
}


export type MarkNotificationReadInput = {
  notificationId: UUID;
};

export type MarkNotificationReadFields = UnifiedFieldSelection<NotificationReadResourceSchema>[];

export type InferMarkNotificationReadResult<
  Fields extends MarkNotificationReadFields | undefined,
> = InferResult<NotificationReadResourceSchema, Fields>;

export type MarkNotificationReadResult<Fields extends MarkNotificationReadFields | undefined = undefined> = | { success: true; data: InferMarkNotificationReadResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new NotificationRead
 *
 * @ashActionType :create
 */
export async function markNotificationRead<Fields extends MarkNotificationReadFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: MarkNotificationReadInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MarkNotificationReadResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "mark_notification_read",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MarkNotificationReadResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new NotificationRead
 *
 * @ashActionType :create
 */
export async function markNotificationReadChannel<Fields extends MarkNotificationReadFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: MarkNotificationReadInput;
  fields?: Fields;
  resultHandler: (result: MarkNotificationReadResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<MarkNotificationReadResult<Fields>>(
    config.channel,
    {
    action: "mark_notification_read",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type MarkNotificationUnreadInput = {
  notificationId: UUID;
};

export type InferMarkNotificationUnreadResult = Record<string, any>;

export type MarkNotificationUnreadResult = | { success: true; data: InferMarkNotificationUnreadResult; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Execute generic action on NotificationRead
 *
 * @ashActionType :action
 */
export async function markNotificationUnread(
  config: {
  tenant?: string;
  input: MarkNotificationUnreadInput;
  hookCtx?: ActionHookContext;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MarkNotificationUnreadResult> {
  const payload = {
    action: "mark_notification_unread",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeActionRpcRequest<MarkNotificationUnreadResult>(
    payload,
    config
  );
}


/**
 * Execute generic action on NotificationRead
 *
 * @ashActionType :action
 */
export async function markNotificationUnreadChannel(config: {
  channel: Channel;
  tenant?: string;
  input: MarkNotificationUnreadInput;
  resultHandler: (result: MarkNotificationUnreadResult) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<MarkNotificationUnreadResult>(
    config.channel,
    {
    action: "mark_notification_unread",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  },
    config.timeout,
    config
  );
}


export type RequestFileUploadInput = {
  filename: string;
  contentType?: string;
  fileType: "thumbnail" | "avatar" | "video" | "other";
  estimatedSize: number;
};

export type RequestFileUploadFields = UnifiedFieldSelection<FileResourceSchema>[];

export type InferRequestFileUploadResult<
  Fields extends RequestFileUploadFields | undefined,
> = InferResult<FileResourceSchema, Fields>;

export type RequestFileUploadResult<Fields extends RequestFileUploadFields | undefined = undefined> = | { success: true; data: InferRequestFileUploadResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new File
 *
 * @ashActionType :create
 */
export async function requestFileUpload<Fields extends RequestFileUploadFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: RequestFileUploadInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RequestFileUploadResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "request_file_upload",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<RequestFileUploadResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new File
 *
 * @ashActionType :create
 */
export async function requestFileUploadChannel<Fields extends RequestFileUploadFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: RequestFileUploadInput;
  fields?: Fields;
  resultHandler: (result: RequestFileUploadResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<RequestFileUploadResult<Fields>>(
    config.channel,
    {
    action: "request_file_upload",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ConfirmFileUploadInput = {
  contentHash?: string | null;
};

export type ConfirmFileUploadFields = UnifiedFieldSelection<FileResourceSchema>[];

export type InferConfirmFileUploadResult<
  Fields extends ConfirmFileUploadFields | undefined,
> = InferResult<FileResourceSchema, Fields>;

export type ConfirmFileUploadResult<Fields extends ConfirmFileUploadFields | undefined = undefined> = | { success: true; data: InferConfirmFileUploadResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing File
 *
 * @ashActionType :update
 */
export async function confirmFileUpload<Fields extends ConfirmFileUploadFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: ConfirmFileUploadInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ConfirmFileUploadResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "confirm_file_upload",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ConfirmFileUploadResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing File
 *
 * @ashActionType :update
 */
export async function confirmFileUploadChannel<Fields extends ConfirmFileUploadFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  input?: ConfirmFileUploadInput;
  fields?: Fields;
  resultHandler: (result: ConfirmFileUploadResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ConfirmFileUploadResult<Fields>>(
    config.channel,
    {
    action: "confirm_file_upload",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type CreateSupportTicketInput = {
  subject: string;
  userId: UUID;
  ticketType?: "support" | "feature_request" | "bug_report";
};

export type CreateSupportTicketFields = UnifiedFieldSelection<SupportTicketResourceSchema>[];

export type InferCreateSupportTicketResult<
  Fields extends CreateSupportTicketFields | undefined,
> = InferResult<SupportTicketResourceSchema, Fields>;

export type CreateSupportTicketResult<Fields extends CreateSupportTicketFields | undefined = undefined> = | { success: true; data: InferCreateSupportTicketResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Ticket
 *
 * @ashActionType :create
 */
export async function createSupportTicket<Fields extends CreateSupportTicketFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateSupportTicketInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateSupportTicketResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_support_ticket",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateSupportTicketResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new Ticket
 *
 * @ashActionType :create
 */
export async function createSupportTicketChannel<Fields extends CreateSupportTicketFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: CreateSupportTicketInput;
  fields?: Fields;
  resultHandler: (result: CreateSupportTicketResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<CreateSupportTicketResult<Fields>>(
    config.channel,
    {
    action: "create_support_ticket",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type ResolveSupportTicketFields = UnifiedFieldSelection<SupportTicketResourceSchema>[];

export type InferResolveSupportTicketResult<
  Fields extends ResolveSupportTicketFields | undefined,
> = InferResult<SupportTicketResourceSchema, Fields>;

export type ResolveSupportTicketResult<Fields extends ResolveSupportTicketFields | undefined = undefined> = | { success: true; data: InferResolveSupportTicketResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Ticket
 *
 * @ashActionType :update
 */
export async function resolveSupportTicket<Fields extends ResolveSupportTicketFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ResolveSupportTicketResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "resolve_support_ticket",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ResolveSupportTicketResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Update an existing Ticket
 *
 * @ashActionType :update
 */
export async function resolveSupportTicketChannel<Fields extends ResolveSupportTicketFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  resultHandler: (result: ResolveSupportTicketResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<ResolveSupportTicketResult<Fields>>(
    config.channel,
    {
    action: "resolve_support_ticket",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


export type SendSupportMessageInput = {
  content: string;
  ticketId: UUID;
  userId: UUID;
};

export type SendSupportMessageFields = UnifiedFieldSelection<SupportMessageResourceSchema>[];

export type InferSendSupportMessageResult<
  Fields extends SendSupportMessageFields | undefined,
> = InferResult<SupportMessageResourceSchema, Fields>;

export type SendSupportMessageResult<Fields extends SendSupportMessageFields | undefined = undefined> = | { success: true; data: InferSendSupportMessageResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Message
 *
 * @ashActionType :create
 */
export async function sendSupportMessage<Fields extends SendSupportMessageFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: SendSupportMessageInput;
  hookCtx?: ActionHookContext;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SendSupportMessageResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "send_support_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<SendSupportMessageResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Create a new Message
 *
 * @ashActionType :create
 */
export async function sendSupportMessageChannel<Fields extends SendSupportMessageFields | undefined = undefined>(config: {
  channel: Channel;
  tenant?: string;
  input: SendSupportMessageInput;
  fields?: Fields;
  resultHandler: (result: SendSupportMessageResult<Fields>) => void;
  errorHandler?: (error: any) => void;
  timeoutHandler?: () => void;
  timeout?: number;
}) {
  executeActionChannelPush<SendSupportMessageResult<Fields>>(
    config.channel,
    {
    action: "send_support_message",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  },
    config.timeout,
    config
  );
}


